<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRLib: prl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PRLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceprl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">prl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5d7d6284a4c0c7cda058575a909d38d4"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a5d7d6284a4c0c7cda058575a909d38d4">FBCITB_ParamsMap</a></td></tr>
<tr class="memdesc:a5d7d6284a4c0c7cda058575a909d38d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of binarization parameters.  <a href="#a5d7d6284a4c0c7cda058575a909d38d4">More...</a><br /></td></tr>
<tr class="separator:a5d7d6284a4c0c7cda058575a909d38d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afae4006d10c814bae355e0fef9b2e482"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482">OPERATIONS</a> { <br />
&#160;&#160;<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482a65cecaea4f1c354c7313229810618f22">OPERATIONS::USE_CANNY</a> = 1, 
<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482a623b46d066141a9a74f9b9525e5f9a0c">OPERATIONS::USE_VARIANCES</a> = 2, 
<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482afcc7bb7e23a66d05bc08966fdc457674">OPERATIONS::USE_CANNY_ON_VARIANCES</a> = 32, 
<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482a770420841f27e561c7ec9db7d8688ab5">OPERATIONS::USE_OTHER_COLOR_SPACE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482adbe8bc8f455d608947d03d114840a3fd">OPERATIONS::USE_CLAHE</a> = 128, 
<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482a41900a14fabcc442c0d62bce89712f70">OPERATIONS::USE_BILATERAL</a> = 256, 
<a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482a4c0ac52a0d346e916fb631f03398c26c">OPERATIONS::USE_MORPHOLOGY</a> = 512
<br />
 }<tr class="memdesc:afae4006d10c814bae355e0fef9b2e482"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of operations to use in binarization procedure.  <a href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afae4006d10c814bae355e0fef9b2e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801f21a62616a360edd449ee24c9f1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1c">FBCITB_ParamsCodes</a> { <br />
&#160;&#160;<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca005087d01ddd9fd29876a6d793f2b7b2">FBCITB_ParamsCodes::COLOR_SPACE</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1caf69a6e95a176a9b15ad5284c357c67eb">FBCITB_ParamsCodes::CLAHE_CLIP_LIMIT</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1cad786f136b0e8c8f4a5a464df69b88347">FBCITB_ParamsCodes::BILATERAL_FILTER_KERNEL_SIZE</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1caf96fd854f10f4ad28ce886e6bb4c1cd0">FBCITB_ParamsCodes::BILATERAL_FILTER_KERNEL_INTENSITY_SIGMA</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca31271aba2f260d029fd143eb7314b147">FBCITB_ParamsCodes::BILATERAL_FILTER_KERNEL_SPATIAL_SIGMA</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca0ca791652bbd596e0c62eb0278ce23e8">FBCITB_ParamsCodes::CANNY_GAUSSIAN_BLUR_KERNEL_SIZE</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca746e9b100fd6f0302f118f063ff6b410">FBCITB_ParamsCodes::CANNY_LOWER_THRESHOLD_COEFF</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1cadd084238b94ca0a81da034d42df55054">FBCITB_ParamsCodes::CANNY_UPPER_THRESHOLD_COEFF</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca32d080879dfe403cb24b466aee01026b">FBCITB_ParamsCodes::VARIANCE_MAP_THRESHOLD</a>, 
<a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1ca695e11a441596411206560b04d1b5a0d">FBCITB_ParamsCodes::BOUNDING_RECT_MAX_AREA_COEFF</a>
<br />
 }<tr class="memdesc:ac801f21a62616a360edd449ee24c9f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible processing parameter codes.  <a href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac801f21a62616a360edd449ee24c9f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0684d839a64e9dabbce6ad985fdf33e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#af0684d839a64e9dabbce6ad985fdf33e">backgroundNormalization</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:af0684d839a64e9dabbce6ad985fdf33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize background.  <a href="#af0684d839a64e9dabbce6ad985fdf33e">More...</a><br /></td></tr>
<tr class="separator:af0684d839a64e9dabbce6ad985fdf33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dba5a98da50aae8506c8df990ccf94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac7dba5a98da50aae8506c8df990ccf94">colorBalance</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, double colorBalanceGamma, double saturationGamma)</td></tr>
<tr class="separator:ac7dba5a98da50aae8506c8df990ccf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dcf2bcc5a977e4b267da49a4f554f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a18dcf2bcc5a977e4b267da49a4f554f1">getAverageValues</a> (const cv::Mat &amp;src, double *ml, double *ma, double *mb, const double p)</td></tr>
<tr class="separator:a18dcf2bcc5a977e4b267da49a4f554f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de8dfc136b2460122ca8777e9468d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a8de8dfc136b2460122ca8777e9468d65">grayWorldWhiteBalance</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const double pNorm, const bool withMax)</td></tr>
<tr class="separator:a8de8dfc136b2460122ca8777e9468d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7499f593e17cb33f05fa3015b04fd368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a7499f593e17cb33f05fa3015b04fd368">simpleWhiteBalance</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const double k)</td></tr>
<tr class="separator:a7499f593e17cb33f05fa3015b04fd368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f9ffa59930a640a76bbad06663aee"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t count&gt; </td></tr>
<tr class="memitem:a003f9ffa59930a640a76bbad06663aee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a003f9ffa59930a640a76bbad06663aee">applyGammaCorrection</a> (cv::Mat &amp;outputImageMat, const std::vector&lt; unsigned char &gt; &amp;lut)</td></tr>
<tr class="separator:a003f9ffa59930a640a76bbad06663aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109afd7000b318a8bf69d013d37852ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a109afd7000b318a8bf69d013d37852ef">gammaCorrection</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const double k, const double gamma)</td></tr>
<tr class="separator:a109afd7000b318a8bf69d013d37852ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe9ce1020a6ec08291055321abc479e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a5fe9ce1020a6ec08291055321abc479e">binarizeAGT</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const int medianKernelSize, const double maxValue, const int blockSize, const int shift)</td></tr>
<tr class="separator:a5fe9ce1020a6ec08291055321abc479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975b116109a72c4047367cd71364a453"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a975b116109a72c4047367cd71364a453">binarizeAT</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const int medianKernelSize, const double maxValue, const int blockSize, const int shift)</td></tr>
<tr class="separator:a975b116109a72c4047367cd71364a453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20040fccd9f702c78a1be2533849835e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a20040fccd9f702c78a1be2533849835e">binarizeCOCOCLUST</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const float T_S=45, double CLAHEClipLimit=3.0, int GaussianBlurKernelSize=19, double CannyUpperThresholdCoeff=0.15, double CannyLowerThresholdCoeff=0.05, int CannyMorphIters=4)</td></tr>
<tr class="memdesc:a20040fccd9f702c78a1be2533849835e"><td class="mdescLeft">&#160;</td><td class="mdescRight">binarizeCOCOCLUST  <a href="#a20040fccd9f702c78a1be2533849835e">More...</a><br /></td></tr>
<tr class="separator:a20040fccd9f702c78a1be2533849835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0262702071bf940b4079b509fd3be5"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#adf0262702071bf940b4079b509fd3be5">binarizeFBCITB</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, bool useCanny=true, bool useVariancesMap=true, bool useCLAHE=true, bool useBilateral=true, bool useOtherColorspace=false, bool useMorphology=true, bool useCannyOnVariances=true, double varianceMapThreshold=200.0, double CLAHEClipLimit=2.0, double gaussianBlurKernelSize=9.0, double cannyUpperThresholdCoeff=0.6, double cannyLowerThresholdCoeff=0.4, double boundingRectangleMaxArea=0.3, int bilateralKernelSize=5, double bilateralKernelIntensitySigma=150.0, double bilateralKernelSpatialSigma=150.0, double boundingRectMaxAreaCoeff=0.3)</td></tr>
<tr class="memdesc:adf0262702071bf940b4079b509fd3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of font and background color independent text binarization.  <a href="#adf0262702071bf940b4079b509fd3be5">More...</a><br /></td></tr>
<tr class="separator:adf0262702071bf940b4079b509fd3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4865fc9de2ade0605febdef2d32084b8"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a4865fc9de2ade0605febdef2d32084b8">binarizeFeng</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int windowSize=21, double thresholdCoefficient_alpha1=0.75, double thresholdCoefficient_k1=0.2, double thresholdCoefficient_k2=0.03, double thresholdCoefficient_gamma=2.0, int morphIterationCount=2)</td></tr>
<tr class="memdesc:a4865fc9de2ade0605febdef2d32084b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feng binarization algorithm implementation.  <a href="#a4865fc9de2ade0605febdef2d32084b8">More...</a><br /></td></tr>
<tr class="separator:a4865fc9de2ade0605febdef2d32084b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30561efb60589a5698aa88bf51a0d17b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a30561efb60589a5698aa88bf51a0d17b">binarizeGAT</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const int gaussianKernelSize, const double sigmaX, const double sigmaY, const double maxValue, const int blockSize, const int shift)</td></tr>
<tr class="separator:a30561efb60589a5698aa88bf51a0d17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac222a3fbf4cf2e4d2e7db217c836da72"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac222a3fbf4cf2e4d2e7db217c836da72">binarizeLocalOtsu</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, double maxValue=255.0, double CLAHEClipLimit=0.0, int GaussianBlurKernelSize=19, double CannyUpperThresholdCoeff=0.15, double CannyLowerThresholdCoeff=0.01, int CannyMorphIters=1)</td></tr>
<tr class="memdesc:ac222a3fbf4cf2e4d2e7db217c836da72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of local Otsu binarization algorithm.  <a href="#ac222a3fbf4cf2e4d2e7db217c836da72">More...</a><br /></td></tr>
<tr class="separator:ac222a3fbf4cf2e4d2e7db217c836da72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd0e32f5237d9306ac58e19eb2a830d"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a4bd0e32f5237d9306ac58e19eb2a830d">binarizeNativeAdaptive</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, bool isGaussianBlurReqiured=0, int medianBlurKernelSize=5, int GaussianBlurKernelSize=7, double GaussianBlurSigma=150.0, bool isAdaptiveThresholdCalculatedByGaussian=true, double adaptiveThresholdingMaxValue=255.0, int adaptiveThresholdingBlockSize=19, double adaptiveThresholdingShift=9, int bilateralFilterBlockSize=0, double bilateralFilterColorSigma=150.0, double bilateralFilterSpaceSigma=150.0)</td></tr>
<tr class="memdesc:a4bd0e32f5237d9306ac58e19eb2a830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native adaptive thresholding.  <a href="#a4bd0e32f5237d9306ac58e19eb2a830d">More...</a><br /></td></tr>
<tr class="separator:a4bd0e32f5237d9306ac58e19eb2a830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473187444b23be2d2bff7e69341c300b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a473187444b23be2d2bff7e69341c300b">binarizeNiblack</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int windowSize=101, double thresholdCoefficient=0.01, int morphIterationCount=2)</td></tr>
<tr class="memdesc:a473187444b23be2d2bff7e69341c300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Niblack binarization algorithm implementation.  <a href="#a473187444b23be2d2bff7e69341c300b">More...</a><br /></td></tr>
<tr class="separator:a473187444b23be2d2bff7e69341c300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0f13f21a05d1fd27f5ea2058c26ee"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a4fe0f13f21a05d1fd27f5ea2058c26ee">binarizeNICK</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int windowSize=21, double thresholdCoefficient=-0.01, int morphIterationCount=0)</td></tr>
<tr class="memdesc:a4fe0f13f21a05d1fd27f5ea2058c26ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">NICK binarization algorithm implementation.  <a href="#a4fe0f13f21a05d1fd27f5ea2058c26ee">More...</a><br /></td></tr>
<tr class="separator:a4fe0f13f21a05d1fd27f5ea2058c26ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683440030dc0a272d9be0b578541ec7c"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a683440030dc0a272d9be0b578541ec7c">binarizePureAdaptive</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const double maxValue, const int blockSize, const int shift)</td></tr>
<tr class="separator:a683440030dc0a272d9be0b578541ec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968e2484752301c0cdf730e76fa0c3e3"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a968e2484752301c0cdf730e76fa0c3e3">binarizePureAdaptiveGaussian</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const double maxValue, const int blockSize, const int shift)</td></tr>
<tr class="separator:a968e2484752301c0cdf730e76fa0c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea37b02134bcd205b27570f63ef37f8"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a5ea37b02134bcd205b27570f63ef37f8">binarizeSauvola</a> (cv::Mat &amp;imageInput, cv::Mat &amp;outputImage, int windowSize=101, double thresholdCoefficient=0.01, int morphIterationCount=2)</td></tr>
<tr class="memdesc:a5ea37b02134bcd205b27570f63ef37f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sauvola binarization algorithm implementation.  <a href="#a5ea37b02134bcd205b27570f63ef37f8">More...</a><br /></td></tr>
<tr class="separator:a5ea37b02134bcd205b27570f63ef37f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e81a408e9442e41e62fbfa2fbf8fd34"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a0e81a408e9442e41e62fbfa2fbf8fd34">binarizeWolfJolion</a> (cv::Mat &amp;imageInput, cv::Mat &amp;outputImage, int windowSize=101, double thresholdCoefficient=0.01, int morphIterationCount=2)</td></tr>
<tr class="memdesc:a0e81a408e9442e41e62fbfa2fbf8fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">WolfJolion binarization algorithm implementation.  <a href="#a0e81a408e9442e41e62fbfa2fbf8fd34">More...</a><br /></td></tr>
<tr class="separator:a0e81a408e9442e41e62fbfa2fbf8fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a1c8a6d3af010902b1809a93812ce2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#aa4a1c8a6d3af010902b1809a93812ce2">documentContour</a> (cv::Mat &amp;inputImage, const double scaleX, const double scaleY, std::vector&lt; cv::Point2f &gt; &amp;resultContour)</td></tr>
<tr class="memdesc:aa4a1c8a6d3af010902b1809a93812ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find document contour.  <a href="#aa4a1c8a6d3af010902b1809a93812ce2">More...</a><br /></td></tr>
<tr class="separator:aa4a1c8a6d3af010902b1809a93812ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe21263f9513e5c07b7309f3f5c82f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a0fe21263f9513e5c07b7309f3f5c82f5">autoCrop</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:a0fe21263f9513e5c07b7309f3f5c82f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop scanned document automatically.  <a href="#a0fe21263f9513e5c07b7309f3f5c82f5">More...</a><br /></td></tr>
<tr class="separator:a0fe21263f9513e5c07b7309f3f5c82f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae553dcfffdf2d727c1a335c26c9c93de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ae553dcfffdf2d727c1a335c26c9c93de">findHoughLineContour</a> (cv::Mat &amp;inputImage, std::vector&lt; cv::Point &gt; &amp;resultContour)</td></tr>
<tr class="separator:ae553dcfffdf2d727c1a335c26c9c93de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5ad21daeb885c71f212a04be23f23"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ad8a5ad21daeb885c71f212a04be23f23">correctNUIL</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int structuringElementSize=31)</td></tr>
<tr class="separator:ad8a5ad21daeb885c71f212a04be23f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bde7423f129895263d77a3d55cda6b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ad4bde7423f129895263d77a3d55cda6b">basicDeblur</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const size_t gaussianKernelSize=0, const double sigmaX=9.0, const double sigmaY=0.0, const double imageWeight=0.75)</td></tr>
<tr class="separator:ad4bde7423f129895263d77a3d55cda6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4847e8cfe37fa1bcbf18864a4a17c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac4847e8cfe37fa1bcbf18864a4a17c24">wienerFilter</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int filterKernelWidth=11, int filterKernelHeight=11, double coeffWiener=1, double sigmaGauss=5)</td></tr>
<tr class="separator:ac4847e8cfe37fa1bcbf18864a4a17c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddc0a765a6a80440a4e51feec8c995a"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a7ddc0a765a6a80440a4e51feec8c995a">denoise</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, double strength=5.5)</td></tr>
<tr class="separator:a7ddc0a765a6a80440a4e51feec8c995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ca4e5343e827cefa63522ccf69e9ac"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a63ca4e5343e827cefa63522ccf69e9ac">denoiseSaltPepper</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, int kernelSize, size_t times)</td></tr>
<tr class="memdesc:a63ca4e5343e827cefa63522ccf69e9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove Salt-Pepper noise.  <a href="#a63ca4e5343e827cefa63522ccf69e9ac">More...</a><br /></td></tr>
<tr class="separator:a63ca4e5343e827cefa63522ccf69e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73f8993548a040c0e9969727341b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#aac73f8993548a040c0e9969727341b54">denoiseKuwahara</a> (const cv::Mat &amp;input_img, cv::Mat &amp;outputImage, size_t iterations)</td></tr>
<tr class="separator:aac73f8993548a040c0e9969727341b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83092a96fdee80720d8a315fb572e26"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac83092a96fdee80720d8a315fb572e26">deskew</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:ac83092a96fdee80720d8a315fb572e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deskew image of document.  <a href="#ac83092a96fdee80720d8a315fb572e26">More...</a><br /></td></tr>
<tr class="separator:ac83092a96fdee80720d8a315fb572e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81bc497d0d7a804f4a4a6d254b1d0d"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#abf81bc497d0d7a804f4a4a6d254b1d0d">findOrientation</a> (const cv::Mat &amp;inputImage)</td></tr>
<tr class="memdesc:abf81bc497d0d7a804f4a4a6d254b1d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find orientation of an image.  <a href="#abf81bc497d0d7a804f4a4a6d254b1d0d">More...</a><br /></td></tr>
<tr class="separator:abf81bc497d0d7a804f4a4a6d254b1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eacb78ea6d9ce4147996ffffcc0efe"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a24eacb78ea6d9ce4147996ffffcc0efe">findAngle</a> (const cv::Mat &amp;inputImage)</td></tr>
<tr class="memdesc:a24eacb78ea6d9ce4147996ffffcc0efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find angle of an image.  <a href="#a24eacb78ea6d9ce4147996ffffcc0efe">More...</a><br /></td></tr>
<tr class="separator:a24eacb78ea6d9ce4147996ffffcc0efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66d7da3e395731f20b961e59d2d543"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a3c66d7da3e395731f20b961e59d2d543">isBlurred</a> (const cv::Mat &amp;inputImage)</td></tr>
<tr class="separator:a3c66d7da3e395731f20b961e59d2d543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a9f4e484ae7aefc5db2398ee26e487"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#af4a9f4e484ae7aefc5db2398ee26e487">isGlared</a> (const cv::Mat &amp;inputImage)</td></tr>
<tr class="separator:af4a9f4e484ae7aefc5db2398ee26e487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13586ad3476ef8e3ab7f5a1a962f2b8b"><td class="memItemLeft" align="right" valign="top">PIX *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a13586ad3476ef8e3ab7f5a1a962f2b8b">opencvToLeptonica</a> (const cv::Mat *inputImage)</td></tr>
<tr class="separator:a13586ad3476ef8e3ab7f5a1a962f2b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad941870f5d7cb127ae7891c87c6b1ff7"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ad941870f5d7cb127ae7891c87c6b1ff7">leptonicaToOpenCV</a> (PIX *inputImage)</td></tr>
<tr class="separator:ad941870f5d7cb127ae7891c87c6b1ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2a42569bb06af854706bc67e419c78"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ade2a42569bb06af854706bc67e419c78">removeDots</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:ade2a42569bb06af854706bc67e419c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove dots on an image.  <a href="#ade2a42569bb06af854706bc67e419c78">More...</a><br /></td></tr>
<tr class="separator:ade2a42569bb06af854706bc67e419c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8a522dc3d0b900906da43eaa6d7d24"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a6c8a522dc3d0b900906da43eaa6d7d24">removeHolePunch</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:a6c8a522dc3d0b900906da43eaa6d7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove hole punches on an image.  <a href="#a6c8a522dc3d0b900906da43eaa6d7d24">More...</a><br /></td></tr>
<tr class="separator:a6c8a522dc3d0b900906da43eaa6d7d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c7ae723dcb243cf37200c863366dca"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ab4c7ae723dcb243cf37200c863366dca">removeLines</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:ab4c7ae723dcb243cf37200c863366dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove lines on an image.  <a href="#ab4c7ae723dcb243cf37200c863366dca">More...</a><br /></td></tr>
<tr class="separator:ab4c7ae723dcb243cf37200c863366dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc923b8457dccdb46d4eb54bce9b846e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#abc923b8457dccdb46d4eb54bce9b846e">resize</a> (const cv::Mat &amp;src, cv::Mat &amp;dst, int scaleX, int scaleY, int maxSize)</td></tr>
<tr class="separator:abc923b8457dccdb46d4eb54bce9b846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4490cacf49eae13952bdc7943d2f3404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a4490cacf49eae13952bdc7943d2f3404">rotate</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, double angle)</td></tr>
<tr class="memdesc:a4490cacf49eae13952bdc7943d2f3404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate image.  <a href="#a4490cacf49eae13952bdc7943d2f3404">More...</a><br /></td></tr>
<tr class="separator:a4490cacf49eae13952bdc7943d2f3404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929f7cbfcabf9f905cfb12bb71b7fdaa"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS std::pair&lt; cv::Point, cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a929f7cbfcabf9f905cfb12bb71b7fdaa">findVertLine</a> (const cv::Mat &amp;inputImage)</td></tr>
<tr class="memdesc:a929f7cbfcabf9f905cfb12bb71b7fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find border between two pages.  <a href="#a929f7cbfcabf9f905cfb12bb71b7fdaa">More...</a><br /></td></tr>
<tr class="separator:a929f7cbfcabf9f905cfb12bb71b7fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270214848e515599d17cc9221d897540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a270214848e515599d17cc9221d897540">thinGuoHall</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:a270214848e515599d17cc9221d897540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for thinning a binary image using Guo Hall algorithm.  <a href="#a270214848e515599d17cc9221d897540">More...</a><br /></td></tr>
<tr class="separator:a270214848e515599d17cc9221d897540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b8d9e604ea2c52f2a4e9f8501f73e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ac26b8d9e604ea2c52f2a4e9f8501f73e">thinZhangSuen</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage)</td></tr>
<tr class="memdesc:ac26b8d9e604ea2c52f2a4e9f8501f73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for thinning a binary image using Zhang-Suen algorithm.  <a href="#ac26b8d9e604ea2c52f2a4e9f8501f73e">More...</a><br /></td></tr>
<tr class="separator:ac26b8d9e604ea2c52f2a4e9f8501f73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b0c1520ca8633e26f1e23d8d7cd79d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a60b0c1520ca8633e26f1e23d8d7cd79d">eq_d</a> (const double v1, const double v2, const double delta=1e-7)</td></tr>
<tr class="separator:a60b0c1520ca8633e26f1e23d8d7cd79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ddfc37391baad6995dfd52e775a6ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#ab3ddfc37391baad6995dfd52e775a6ce">compareImages</a> (const cv::Mat &amp;image1, const cv::Mat &amp;image2)</td></tr>
<tr class="separator:ab3ddfc37391baad6995dfd52e775a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaaa4c1c43401be979e7573ec332d37"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#affaaa4c1c43401be979e7573ec332d37">warpCrop</a> (const cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const int x0, const int y0, const int x1, const int y1, const int x2, const int y2, const int x3, const int y3, double ratio=-1.0, const int borderMode=cv::BORDER_CONSTANT, const cv::Scalar &amp;borderValue=cv::Scalar())</td></tr>
<tr class="memdesc:affaaa4c1c43401be979e7573ec332d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform image to crop document.  <a href="#affaaa4c1c43401be979e7573ec332d37">More...</a><br /></td></tr>
<tr class="separator:affaaa4c1c43401be979e7573ec332d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c65d953915ef2871fbba97738dd514e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprl.html#a8c65d953915ef2871fbba97738dd514e">warpCrop</a> (cv::Mat &amp;inputImage, cv::Mat &amp;outputImage, const std::vector&lt; cv::Point &gt; &amp;points, double ratio=-1.0, int borderMode=cv::BORDER_CONSTANT, const cv::Scalar &amp;borderValue=cv::Scalar())</td></tr>
<tr class="memdesc:a8c65d953915ef2871fbba97738dd514e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform image to crop document.  <a href="#a8c65d953915ef2871fbba97738dd514e">More...</a><br /></td></tr>
<tr class="separator:a8c65d953915ef2871fbba97738dd514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5d7d6284a4c0c7cda058575a909d38d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7d6284a4c0c7cda058575a909d38d4">&#9670;&nbsp;</a></span>FBCITB_ParamsMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceprl.html#a5d7d6284a4c0c7cda058575a909d38d4">prl::FBCITB_ParamsMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map of binarization parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1c" title="List of possible processing parameter codes. ">FBCITB_ParamsCodes</a>, <a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482" title="List of operations to use in binarization procedure. ">OPERATIONS</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html#l00076">76</a> of file <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html">binarizeFBCITB.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac801f21a62616a360edd449ee24c9f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac801f21a62616a360edd449ee24c9f1c">&#9670;&nbsp;</a></span>FBCITB_ParamsCodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1c">prl::FBCITB_ParamsCodes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of possible processing parameter codes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482" title="List of operations to use in binarization procedure. ">OPERATIONS</a>, <a class="el" href="namespaceprl.html#a5d7d6284a4c0c7cda058575a909d38d4" title="Map of binarization parameters. ">FBCITB_ParamsMap</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca005087d01ddd9fd29876a6d793f2b7b2"></a>COLOR_SPACE&#160;</td><td class="fielddoc"><p>Color space parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1caf69a6e95a176a9b15ad5284c357c67eb"></a>CLAHE_CLIP_LIMIT&#160;</td><td class="fielddoc"><p>CLAHE procedure parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1cad786f136b0e8c8f4a5a464df69b88347"></a>BILATERAL_FILTER_KERNEL_SIZE&#160;</td><td class="fielddoc"><p>Bilateral filter kernel size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1caf96fd854f10f4ad28ce886e6bb4c1cd0"></a>BILATERAL_FILTER_KERNEL_INTENSITY_SIGMA&#160;</td><td class="fielddoc"><p>Bilateral filter intensity sigma. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca31271aba2f260d029fd143eb7314b147"></a>BILATERAL_FILTER_KERNEL_SPATIAL_SIGMA&#160;</td><td class="fielddoc"><p>Bilateral filter spatial sigma. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca0ca791652bbd596e0c62eb0278ce23e8"></a>CANNY_GAUSSIAN_BLUR_KERNEL_SIZE&#160;</td><td class="fielddoc"><p>Gaussian blur kernel size for Canny edge detector. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca746e9b100fd6f0302f118f063ff6b410"></a>CANNY_LOWER_THRESHOLD_COEFF&#160;</td><td class="fielddoc"><p>Coefficient for lower threshold of Canny edge detector. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1cadd084238b94ca0a81da034d42df55054"></a>CANNY_UPPER_THRESHOLD_COEFF&#160;</td><td class="fielddoc"><p>Coefficient for upper threshold of Canny edge detector. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca32d080879dfe403cb24b466aee01026b"></a>VARIANCE_MAP_THRESHOLD&#160;</td><td class="fielddoc"><p>Threshold value for local variance map. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac801f21a62616a360edd449ee24c9f1ca695e11a441596411206560b04d1b5a0d"></a>BOUNDING_RECT_MAX_AREA_COEFF&#160;</td><td class="fielddoc"><p>Coefficient for maximal possible bounding rectangle area. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html#l00057">57</a> of file <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html">binarizeFBCITB.h</a>.</p>

</div>
</div>
<a id="afae4006d10c814bae355e0fef9b2e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae4006d10c814bae355e0fef9b2e482">&#9670;&nbsp;</a></span>OPERATIONS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceprl.html#afae4006d10c814bae355e0fef9b2e482">prl::OPERATIONS</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of operations to use in binarization procedure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceprl.html#ac801f21a62616a360edd449ee24c9f1c" title="List of possible processing parameter codes. ">FBCITB_ParamsCodes</a>, <a class="el" href="namespaceprl.html#a5d7d6284a4c0c7cda058575a909d38d4" title="Map of binarization parameters. ">FBCITB_ParamsMap</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482a65cecaea4f1c354c7313229810618f22"></a>USE_CANNY&#160;</td><td class="fielddoc"><p>Use Canny edge detector. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482a623b46d066141a9a74f9b9525e5f9a0c"></a>USE_VARIANCES&#160;</td><td class="fielddoc"><p>Use local variance values map. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482afcc7bb7e23a66d05bc08966fdc457674"></a>USE_CANNY_ON_VARIANCES&#160;</td><td class="fielddoc"><p>Apply Canny edge detector to local variance values map. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482a770420841f27e561c7ec9db7d8688ab5"></a>USE_OTHER_COLOR_SPACE&#160;</td><td class="fielddoc"><p>Change processed image color space. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482adbe8bc8f455d608947d03d114840a3fd"></a>USE_CLAHE&#160;</td><td class="fielddoc"><p>Use contrast enhancement. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482a41900a14fabcc442c0d62bce89712f70"></a>USE_BILATERAL&#160;</td><td class="fielddoc"><p>Use bilateral filtration. </p>
</td></tr>
<tr><td class="fieldname"><a id="afae4006d10c814bae355e0fef9b2e482a4c0ac52a0d346e916fb631f03398c26c"></a>USE_MORPHOLOGY&#160;</td><td class="fielddoc"><p>Apply morphology operations. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html#l00039">39</a> of file <a class="el" href="binarize_f_b_c_i_t_b_8h_source.html">binarizeFBCITB.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a003f9ffa59930a640a76bbad06663aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f9ffa59930a640a76bbad06663aee">&#9670;&nbsp;</a></span>applyGammaCorrection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t count&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prl::applyGammaCorrection </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImageMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gamma_correction_8cpp_source.html#l00038">38</a> of file <a class="el" href="gamma_correction_8cpp_source.html">gammaCorrection.cpp</a>.</p>

</div>
</div>
<a id="a0fe21263f9513e5c07b7309f3f5c82f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe21263f9513e5c07b7309f3f5c82f5">&#9670;&nbsp;</a></span>autoCrop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS bool prl::autoCrop </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crop scanned document automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Cropped image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if image cropped. </dd></dl>
<p>Try to detect border</p>
<p>Crop area </p>

<p class="definition">Definition at line <a class="el" href="auto_crop_8cpp_source.html#l00133">133</a> of file <a class="el" href="auto_crop_8cpp_source.html">autoCrop.cpp</a>.</p>

</div>
</div>
<a id="af0684d839a64e9dabbce6ad985fdf33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0684d839a64e9dabbce6ad985fdf33e">&#9670;&nbsp;</a></span>backgroundNormalization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::backgroundNormalization </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize background. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementation is based on Leptonica library </p><dl class="section note"><dt>Note</dt><dd>Implementation of this procedure is based on <a href="http://www.leptonica.com/">Leptonica library</a>.. </dd></dl>

<p class="definition">Definition at line <a class="el" href="background_normalization_8cpp_source.html#l00036">36</a> of file <a class="el" href="background_normalization_8cpp_source.html">backgroundNormalization.cpp</a>.</p>

</div>
</div>
<a id="ad4bde7423f129895263d77a3d55cda6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bde7423f129895263d77a3d55cda6b">&#9670;&nbsp;</a></span>basicDeblur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::basicDeblur </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>gaussianKernelSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigmaX</em> = <code>9.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigmaY</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>imageWeight</em> = <code>0.75</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="basic_deblur_8cpp_source.html#l00033">33</a> of file <a class="el" href="basic_deblur_8cpp_source.html">basicDeblur.cpp</a>.</p>

</div>
</div>
<a id="a5fe9ce1020a6ec08291055321abc479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe9ce1020a6ec08291055321abc479e">&#9670;&nbsp;</a></span>binarizeAGT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeAGT </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>medianKernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binarize_a_g_t_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_a_g_t_8cpp_source.html">binarizeAGT.cpp</a>.</p>

</div>
</div>
<a id="a975b116109a72c4047367cd71364a453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975b116109a72c4047367cd71364a453">&#9670;&nbsp;</a></span>binarizeAT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeAT </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>medianKernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binarize_a_t_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_a_t_8cpp_source.html">binarizeAT.cpp</a>.</p>

</div>
</div>
<a id="a20040fccd9f702c78a1be2533849835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20040fccd9f702c78a1be2533849835e">&#9670;&nbsp;</a></span>binarizeCOCOCLUST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeCOCOCLUST </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>T_S</em> = <code>45</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CLAHEClipLimit</em> = <code>3.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GaussianBlurKernelSize</em> = <code>19</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CannyUpperThresholdCoeff</em> = <code>0.15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CannyLowerThresholdCoeff</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CannyMorphIters</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binarizeCOCOCLUST </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T_S</td><td>Threshold for preliminary clustering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLAHEClipLimit</td><td>Parameter of local contrast enhancement procedure (if less or equal than 0 then procedure is not used). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GaussianBlurKernelSize</td><td>kernel size of Gaussian blur procedure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CannyUpperThresholdCoeff</td><td>Coefficient for upper threshold of Canny edge detector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CannyLowerThresholdCoeff</td><td>Coefficient for lower threshold of Canny edge detector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CannyMorphIters</td><td>Parameter of erode and dilatation (if equal than 0 then procedures are not used). </td></tr>
  </table>
  </dd>
</dl>
<p>Processing for gray scaled image</p>
<p>Intensity channel extraction</p>
<p>Enhance local contrast if it is required</p>
<p>Detect edges by using Canny edge detector</p>
<p>We should have corresponding channels count for processing</p>
<p>Find contours and remove not required</p>
<p>Set width of range for mean calculation</p>
<p>Set constants for normal vector normalization</p>
<p>Set count of normal vectors for each contour</p>
<p>Calculate current contour mean points</p>
<p>Extend contour by copying points from begin to end of array and from end to begin</p>
<p>Get part of contour</p>
<p>Remove duplicate points</p>
<p>Calculate normal vectors</p>
<p>Extend contour by copying points from begin to end of array and from end to begin</p>
<p>Calculate normals</p>
<p>Calculate color prototypes</p>
<p>Calculate point colors for internal and external vectors</p>
<p>Get external vector</p>
<p>Get internal vector</p>
<p>Test points of vector are not placed in processed image</p>
<p>Get colors in corresponding points</p>
<p>Store external vector for further usage</p>
<p>Obtain color medians for colors_p and colors_m and store them to CP for each color channel separately</p>
<p>Store median to color prototypes array</p>
<p>Binarize image:</p>
<p>Set rectangle of processed image</p>
<p>Set default background</p>
<p>Get foreground color value</p>
<p>Get background color value</p>
<p>Binarization in contour bounding rectangle </p>

<p class="definition">Definition at line <a class="el" href="binarize_c_o_c_o_c_l_u_s_t_8cpp_source.html#l00041">41</a> of file <a class="el" href="binarize_c_o_c_o_c_l_u_s_t_8cpp_source.html">binarizeCOCOCLUST.cpp</a>.</p>

</div>
</div>
<a id="adf0262702071bf940b4079b509fd3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0262702071bf940b4079b509fd3be5">&#9670;&nbsp;</a></span>binarizeFBCITB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeFBCITB </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCanny</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useVariancesMap</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCLAHE</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBilateral</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOtherColorspace</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useMorphology</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCannyOnVariances</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>varianceMapThreshold</em> = <code>200.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CLAHEClipLimit</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gaussianBlurKernelSize</em> = <code>9.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cannyUpperThresholdCoeff</em> = <code>0.6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cannyLowerThresholdCoeff</em> = <code>0.4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundingRectangleMaxArea</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bilateralKernelSize</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bilateralKernelIntensitySigma</em> = <code>150.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bilateralKernelSpatialSigma</em> = <code>150.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundingRectMaxAreaCoeff</em> = <code>0.3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of font and background color independent text binarization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operations</td><td>Used operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMap</td><td>Parameters map for operations.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an implementation of "Font and Background Color Independent Text Binarization". </p>
<p>if Canny detector and local variance operations are not used then use both.</p>
<p>contrast enhancement</p>
<p>bilateral filtration</p>
<p>set parameters of filtration</p>
<p>use Canny detector</p>
<p>get map of local variance</p>
<p>contours detection</p>
<p>get bounding rectangles</p>
<p>foreground color</p>
<p>get points near corners of bounding rectangle</p>
<p>get median for each color channel</p>
<p>sorting for further obtaining of medians</p>
<p>background color &ndash; corresponding medians</p>
<p>binarization of area selected by bounding rectangle</p>
<p>binarization</p>
<p>morphology operations </p>

<p class="definition">Definition at line <a class="el" href="binarize_f_b_c_i_t_b_8cpp_source.html#l00073">73</a> of file <a class="el" href="binarize_f_b_c_i_t_b_8cpp_source.html">binarizeFBCITB.cpp</a>.</p>

</div>
</div>
<a id="a4865fc9de2ade0605febdef2d32084b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4865fc9de2ade0605febdef2d32084b8">&#9670;&nbsp;</a></span>binarizeFeng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeFeng </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>21</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient_alpha1</em> = <code>0.75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient_k1</em> = <code>0.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient_k2</em> = <code>0.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient_gamma</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>morphIterationCount</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feng binarization algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for processing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting binary image. </td></tr>
    <tr><td class="paramname">windowSize</td><td>Size of sliding window. </td></tr>
    <tr><td class="paramname">thresholdCoefficient_alpha1</td><td>Coefficient <img class="formulaInl" alt="$\alpha_1$" src="form_0.png"/> for threshold calculation. </td></tr>
    <tr><td class="paramname">thresholdCoefficient_k1</td><td>Coefficient <img class="formulaInl" alt="$k_1$" src="form_1.png"/> for threshold calculation. </td></tr>
    <tr><td class="paramname">thresholdCoefficient_k2</td><td>Coefficient <img class="formulaInl" alt="$k_2$" src="form_2.png"/> for threshold calculation. </td></tr>
    <tr><td class="paramname">thresholdCoefficient_gamma</td><td>Coefficient <img class="formulaInl" alt="$\gamma$" src="form_3.png"/> for threshold calculation. </td></tr>
    <tr><td class="paramname">morphIterationCount</td><td>Count of morphology operation in postprocessing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements algorithm described in article "Comparison of Niblack inspired Binarization methods for ancient documents". </p>
<p>parameters and constants of algorithm</p>
<p>add borders</p>
<p>get integral image, ...</p>
<p>... crop it and ...</p>
<p>get square</p>
<p>create storage for local means</p>
<p>create filter for local means calculation</p>
<p>get local means</p>
<p>create storage for local deviations</p>
<p>create filter for local deviations calculation</p>
<p>get local deviations</p>
<p>calculate Feng thresholds</p>
<p>get binarized image</p>
<p>apply morphology operation if them required </p>

<p class="definition">Definition at line <a class="el" href="binarize_feng_8cpp_source.html#l00031">31</a> of file <a class="el" href="binarize_feng_8cpp_source.html">binarizeFeng.cpp</a>.</p>

</div>
</div>
<a id="a30561efb60589a5698aa88bf51a0d17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30561efb60589a5698aa88bf51a0d17b">&#9670;&nbsp;</a></span>binarizeGAT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeGAT </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gaussianKernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigmaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigmaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binarize_g_a_t_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_g_a_t_8cpp_source.html">binarizeGAT.cpp</a>.</p>

</div>
</div>
<a id="ac222a3fbf4cf2e4d2e7db217c836da72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac222a3fbf4cf2e4d2e7db217c836da72">&#9670;&nbsp;</a></span>binarizeLocalOtsu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeLocalOtsu </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em> = <code>255.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CLAHEClipLimit</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GaussianBlurKernelSize</em> = <code>19</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CannyUpperThresholdCoeff</em> = <code>0.15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CannyLowerThresholdCoeff</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CannyMorphIters</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of local Otsu binarization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for binarization. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting image. </td></tr>
    <tr><td class="paramname">maxValue</td><td>New value for pixel which intensity greater than threshold value. </td></tr>
    <tr><td class="paramname">CLAHEClipLimit</td><td>Parameter for CLAHE procedure. </td></tr>
    <tr><td class="paramname">GaussianBlurKernelSize</td><td>Parameter for Gaussian blur procedure. </td></tr>
    <tr><td class="paramname">CannyUpperThresholdCoeff</td><td>Coefficient for upper threshold of Canny edge detector. </td></tr>
    <tr><td class="paramname">CannyLowerThresholdCoeff</td><td>Coefficient for lower threshold of Canny edge detector. </td></tr>
    <tr><td class="paramname">CannyMorphIters</td><td>Parameter of morphology operations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function consists of next steps:</p><ol type="1">
<li>Histogram enchanting by CLAHE.</li>
<li>Edges detection by Canny.</li>
<li>Morphology operations.</li>
<li>Contours detection.</li>
<li>Binarization by Otsu of bounding rectangle of each contour. </li>
</ol>
<p>input image must be not empty</p>
<p>we work with gray image</p>
<p>get intensity channel only</p>
<p>Enhance local contrast if it is required</p>
<p>detect edges by using Canny edge detector</p>
<p>find contours and remove not required</p>
<p>binarization</p>
<p>for each contour ...</p>
<p>... get boundary rectangle ...</p>
<p>... create copy and ...</p>
<p>binarize it by Otsu</p>
<p>Store binarization result to output image </p>

<p class="definition">Definition at line <a class="el" href="binarize_local_otsu_8cpp_source.html#l00037">37</a> of file <a class="el" href="binarize_local_otsu_8cpp_source.html">binarizeLocalOtsu.cpp</a>.</p>

</div>
</div>
<a id="a4bd0e32f5237d9306ac58e19eb2a830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd0e32f5237d9306ac58e19eb2a830d">&#9670;&nbsp;</a></span>binarizeNativeAdaptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeNativeAdaptive </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGaussianBlurReqiured</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>medianBlurKernelSize</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>GaussianBlurKernelSize</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>GaussianBlurSigma</em> = <code>150.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAdaptiveThresholdCalculatedByGaussian</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adaptiveThresholdingMaxValue</em> = <code>255.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adaptiveThresholdingBlockSize</em> = <code>19</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adaptiveThresholdingShift</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bilateralFilterBlockSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bilateralFilterColorSigma</em> = <code>150.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bilateralFilterSpaceSigma</em> = <code>150.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native adaptive thresholding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for binarization. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting image. </td></tr>
    <tr><td class="paramname">isGaussianBlurReqiured</td><td>Flag of usage Gaussian blur. If this flag equals true then Gaussian blur is used. Else median blur is used.</td></tr>
    <tr><td class="paramname">medianBlurKernelSize</td><td>Kernel size for median blur. </td></tr>
    <tr><td class="paramname">GaussianBlurKernelSize</td><td>Kernel size for Gaussian blur. </td></tr>
    <tr><td class="paramname">GaussianBlurSigma</td><td>Gaussian blur <img class="formulaInl" alt="$\sigma$" src="form_4.png"/>. </td></tr>
    <tr><td class="paramname">isAdaptiveThresholdCalculatedByGaussian</td><td>Flag of base of adaptive thresholding type. If this flag equals true then Gaussian kernel is used. Else mean kernel is used.</td></tr>
    <tr><td class="paramname">adaptiveThresholdingMaxValue</td><td>New value for pixel which intensity greater than threshold value. </td></tr>
    <tr><td class="paramname">adaptiveThresholdingBlockSize</td><td>Kernel size for adaptive thresholding procedure. </td></tr>
    <tr><td class="paramname">adaptiveThresholdingShift</td><td>Shifting value for adaptive thresholding procedure. </td></tr>
    <tr><td class="paramname">bilateralFilterBlockSize</td><td>Kernel size for bilateral filtration. If less than 0 then filtration isn't used. </td></tr>
    <tr><td class="paramname">bilateralFilterColorSigma</td><td>Sigma ( <img class="formulaInl" alt="$\sigma_r$" src="form_5.png"/>) for intensity range. </td></tr>
    <tr><td class="paramname">bilateralFilterSpaceSigma</td><td>Sigma ( <img class="formulaInl" alt="$\sigma_d$" src="form_6.png"/>) for space range.</td></tr>
  </table>
  </dd>
</dl>
<p>This function consists of next steps:</p><ol type="1">
<li>Median/Gaussian blur.</li>
<li>Adaptive threshold.</li>
<li>Bilateral filter. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="binarize_native_adaptive_8cpp_source.html#l00034">34</a> of file <a class="el" href="binarize_native_adaptive_8cpp_source.html">binarizeNativeAdaptive.cpp</a>.</p>

</div>
</div>
<a id="a473187444b23be2d2bff7e69341c300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473187444b23be2d2bff7e69341c300b">&#9670;&nbsp;</a></span>binarizeNiblack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeNiblack </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>101</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>morphIterationCount</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Niblack binarization algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for processing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting binary image. </td></tr>
    <tr><td class="paramname">windowSize</td><td>Size of sliding window. </td></tr>
    <tr><td class="paramname">thresholdCoefficient</td><td>Coefficient for threshold calculation. </td></tr>
    <tr><td class="paramname">morphIterationCount</td><td>Count of morphology operation in postprocessing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements algorithm described in article "Comparison of Niblack inspired Binarization methods for ancient documents". </p>
<p>parameters and constants of algorithm</p>
<p>add borders</p>
<p>get integral image, ...</p>
<p>... crop it and ...</p>
<p>get square</p>
<p>create storage for local means</p>
<p>create filter for local means calculation</p>
<p>get local means</p>
<p>create storage for local deviations</p>
<p>create filter for local deviations calculation</p>
<p>get local deviations</p>
<p>calculate Niblack thresholds</p>
<p>get binarized image</p>
<p>apply morphology operation if them required </p>

<p class="definition">Definition at line <a class="el" href="binarize_niblack_8cpp_source.html#l00032">32</a> of file <a class="el" href="binarize_niblack_8cpp_source.html">binarizeNiblack.cpp</a>.</p>

</div>
</div>
<a id="a4fe0f13f21a05d1fd27f5ea2058c26ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0f13f21a05d1fd27f5ea2058c26ee">&#9670;&nbsp;</a></span>binarizeNICK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeNICK </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>21</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient</em> = <code>-0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>morphIterationCount</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NICK binarization algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for processing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting binary image. </td></tr>
    <tr><td class="paramname">windowSize</td><td>Size of sliding window. </td></tr>
    <tr><td class="paramname">thresholdCoefficient</td><td>Coefficient for threshold calculation. </td></tr>
    <tr><td class="paramname">morphIterationCount</td><td>Count of morphology operation in postprocessing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements algorithm described in article "Comparison of Niblack inspired Binarization methods for ancient documents". </p>
<p>parameters and constants of algorithm</p>
<p>add borders</p>
<p>get integral image, ...</p>
<p>... crop it and ...</p>
<p>get square</p>
<p>create storage for local means</p>
<p>create filter for local means calculation</p>
<p>get local means</p>
<p>create storage for local deviations</p>
<p>create filter for local deviations calculation</p>
<p>get local deviations</p>
<p>calculate WolfJolion thresholds</p>
<p>get binarized image</p>
<p>apply morphology operation if them required </p>

<p class="definition">Definition at line <a class="el" href="binarize_n_i_c_k_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_n_i_c_k_8cpp_source.html">binarizeNICK.cpp</a>.</p>

</div>
</div>
<a id="a683440030dc0a272d9be0b578541ec7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683440030dc0a272d9be0b578541ec7c">&#9670;&nbsp;</a></span>binarizePureAdaptive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizePureAdaptive </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binarize_pure_adaptive_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_pure_adaptive_8cpp_source.html">binarizePureAdaptive.cpp</a>.</p>

</div>
</div>
<a id="a968e2484752301c0cdf730e76fa0c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968e2484752301c0cdf730e76fa0c3e3">&#9670;&nbsp;</a></span>binarizePureAdaptiveGaussian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizePureAdaptiveGaussian </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="binarize_pure_adaptive_gaussian_8cpp_source.html#l00032">32</a> of file <a class="el" href="binarize_pure_adaptive_gaussian_8cpp_source.html">binarizePureAdaptiveGaussian.cpp</a>.</p>

</div>
</div>
<a id="a5ea37b02134bcd205b27570f63ef37f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea37b02134bcd205b27570f63ef37f8">&#9670;&nbsp;</a></span>binarizeSauvola()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeSauvola </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>imageInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>101</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>morphIterationCount</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sauvola binarization algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInput</td><td>Image for processing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting binary image. </td></tr>
    <tr><td class="paramname">windowSize</td><td>Size of sliding window. </td></tr>
    <tr><td class="paramname">thresholdCoefficient</td><td>Coefficient for threshold calculation. </td></tr>
    <tr><td class="paramname">morphIterationCount</td><td>Count of morphology operation in postprocessing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements algorithm described in article "Efficient Implementation of Local Adaptive Thresholding Techniques Using Integral Images". </p>
<p>parameters and constants of algorithm</p>
<p>add borders</p>
<p>get integral image, ...</p>
<p>... crop it and ...</p>
<p>get square</p>
<p>create storage for local means</p>
<p>create filter for local means calculation</p>
<p>get local means</p>
<p>create storage for local deviations</p>
<p>create filter for local deviations calculation</p>
<p>get local deviations</p>
<p>calculate Sauvola thresholds</p>
<p>get binarized image</p>
<p>apply morphology operation if them required </p>

<p class="definition">Definition at line <a class="el" href="binarize_sauvola_8cpp_source.html#l00032">32</a> of file <a class="el" href="binarize_sauvola_8cpp_source.html">binarizeSauvola.cpp</a>.</p>

</div>
</div>
<a id="a0e81a408e9442e41e62fbfa2fbf8fd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e81a408e9442e41e62fbfa2fbf8fd34">&#9670;&nbsp;</a></span>binarizeWolfJolion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::binarizeWolfJolion </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>imageInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>101</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresholdCoefficient</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>morphIterationCount</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WolfJolion binarization algorithm implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInput</td><td>Image for processing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting binary image. </td></tr>
    <tr><td class="paramname">windowSize</td><td>Size of sliding window. </td></tr>
    <tr><td class="paramname">thresholdCoefficient</td><td>Coefficient for threshold calculation. </td></tr>
    <tr><td class="paramname">morphIterationCount</td><td>Count of morphology operation in postprocessing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements algorithm described in article "Comparison of Niblack inspired Binarization methods for ancient documents". </p>
<p>parameters and constants of algorithm</p>
<p>add borders</p>
<p>get integral image, ...</p>
<p>... crop it and ...</p>
<p>get square</p>
<p>create storage for local means</p>
<p>create filter for local means calculation</p>
<p>get local means</p>
<p>create storage for local deviations</p>
<p>create filter for local deviations calculation</p>
<p>get local deviations</p>
<p>calculate WolfJolion thresholds</p>
<p>get binarized image</p>
<p>apply morphology operation if them required </p>

<p class="definition">Definition at line <a class="el" href="binarize_wolf_jolion_8cpp_source.html#l00033">33</a> of file <a class="el" href="binarize_wolf_jolion_8cpp_source.html">binarizeWolfJolion.cpp</a>.</p>

</div>
</div>
<a id="ac7dba5a98da50aae8506c8df990ccf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dba5a98da50aae8506c8df990ccf94">&#9670;&nbsp;</a></span>colorBalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::colorBalance </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colorBalanceGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturationGamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="balance_color_8cpp_source.html#l00034">34</a> of file <a class="el" href="balance_color_8cpp_source.html">balanceColor.cpp</a>.</p>

</div>
</div>
<a id="ab3ddfc37391baad6995dfd52e775a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ddfc37391baad6995dfd52e775a6ce">&#9670;&nbsp;</a></span>compareImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prl::compareImages </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00037">37</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="ad8a5ad21daeb885c71f212a04be23f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a5ad21daeb885c71f212a04be23f23">&#9670;&nbsp;</a></span>correctNUIL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::correctNUIL </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>structuringElementSize</em> = <code>31</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="correct_n_u_i_l_8cpp_source.html#l00055">55</a> of file <a class="el" href="correct_n_u_i_l_8cpp_source.html">correctNUIL.cpp</a>.</p>

</div>
</div>
<a id="a7ddc0a765a6a80440a4e51feec8c995a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddc0a765a6a80440a4e51feec8c995a">&#9670;&nbsp;</a></span>denoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::denoise </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>strength</em> = <code>5.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="denoise_n_l_m_8cpp_source.html#l00029">29</a> of file <a class="el" href="denoise_n_l_m_8cpp_source.html">denoiseNLM.cpp</a>.</p>

</div>
</div>
<a id="aac73f8993548a040c0e9969727341b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac73f8993548a040c0e9969727341b54">&#9670;&nbsp;</a></span>denoiseKuwahara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::denoiseKuwahara </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>input_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="kuwahara_filter_8cpp_source.html#l00138">138</a> of file <a class="el" href="kuwahara_filter_8cpp_source.html">kuwaharaFilter.cpp</a>.</p>

</div>
</div>
<a id="a63ca4e5343e827cefa63522ccf69e9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ca4e5343e827cefa63522ccf69e9ac">&#9670;&nbsp;</a></span>denoiseSaltPepper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::denoiseSaltPepper </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove Salt-Pepper noise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernelSize</td><td>Kernel size for median filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Filter running times.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementation uses medianFilter for denoising. </p>

<p class="definition">Definition at line <a class="el" href="denoise_salt_pepper_8cpp_source.html#l00029">29</a> of file <a class="el" href="denoise_salt_pepper_8cpp_source.html">denoiseSaltPepper.cpp</a>.</p>

</div>
</div>
<a id="ac83092a96fdee80720d8a315fb572e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83092a96fdee80720d8a315fb572e26">&#9670;&nbsp;</a></span>deskew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS bool prl::deskew </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deskew image of document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for deskewing. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Deskewed image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if processing successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implementation of this procedure is based on <a href="http://www.leptonica.com/">Leptonica library</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="deskew_8cpp_source.html#l00208">208</a> of file <a class="el" href="deskew_8cpp_source.html">deskew.cpp</a>.</p>

</div>
</div>
<a id="aa4a1c8a6d3af010902b1809a93812ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a1c8a6d3af010902b1809a93812ce2">&#9670;&nbsp;</a></span>documentContour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS bool prl::documentContour </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultContour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find document contour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleX</td><td>Horizontal scale factor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleY</td><td>Vertical scale factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultContour</td><td>Contour of a document. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contour exists, false otherwise. </dd></dl>
<p>Store source image size </p>

<p class="definition">Definition at line <a class="el" href="auto_crop_8cpp_source.html#l00043">43</a> of file <a class="el" href="auto_crop_8cpp_source.html">autoCrop.cpp</a>.</p>

</div>
</div>
<a id="a60b0c1520ca8633e26f1e23d8d7cd79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b0c1520ca8633e26f1e23d8d7cd79d">&#9670;&nbsp;</a></span>eq_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prl::eq_d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00032">32</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="a24eacb78ea6d9ce4147996ffffcc0efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eacb78ea6d9ce4147996ffffcc0efe">&#9670;&nbsp;</a></span>findAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prl::findAngle </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find angle of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for deskewing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle of an image.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implementation of this procedure is based on <a href="http://www.leptonica.com/">Leptonica library</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="deskew_8cpp_source.html#l00139">139</a> of file <a class="el" href="deskew_8cpp_source.html">deskew.cpp</a>.</p>

</div>
</div>
<a id="ae553dcfffdf2d727c1a335c26c9c93de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae553dcfffdf2d727c1a335c26c9c93de">&#9670;&nbsp;</a></span>findHoughLineContour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prl::findHoughLineContour </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultContour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hough_line_8cpp_source.html#l00192">192</a> of file <a class="el" href="hough_line_8cpp_source.html">houghLine.cpp</a>.</p>

</div>
</div>
<a id="abf81bc497d0d7a804f4a4a6d254b1d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf81bc497d0d7a804f4a4a6d254b1d0d">&#9670;&nbsp;</a></span>findOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double prl::findOrientation </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find orientation of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for detecting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle which describes orientation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implementation of this procedure is based on <a href="http://www.leptonica.com/">Leptonica library</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="deskew_8cpp_source.html#l00070">70</a> of file <a class="el" href="deskew_8cpp_source.html">deskew.cpp</a>.</p>

</div>
</div>
<a id="a929f7cbfcabf9f905cfb12bb71b7fdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929f7cbfcabf9f905cfb12bb71b7fdaa">&#9670;&nbsp;</a></span>findVertLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS std::pair&lt;cv::Point, cv::Point&gt; prl::findVertLine </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find border between two pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image.</td></tr>
  </table>
  </dd>
</dl>
<p>Try to find vertical line on the image. Should be used if you have image with two pages. </p>

</div>
</div>
<a id="a109afd7000b318a8bf69d013d37852ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109afd7000b318a8bf69d013d37852ef">&#9670;&nbsp;</a></span>gammaCorrection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::gammaCorrection </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gamma_correction_8cpp_source.html#l00052">52</a> of file <a class="el" href="gamma_correction_8cpp_source.html">gammaCorrection.cpp</a>.</p>

</div>
</div>
<a id="a18dcf2bcc5a977e4b267da49a4f554f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18dcf2bcc5a977e4b267da49a4f554f1">&#9670;&nbsp;</a></span>getAverageValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::getAverageValues </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="balance_gray_world_white_8cpp_source.html#l00037">37</a> of file <a class="el" href="balance_gray_world_white_8cpp_source.html">balanceGrayWorldWhite.cpp</a>.</p>

</div>
</div>
<a id="a8de8dfc136b2460122ca8777e9468d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de8dfc136b2460122ca8777e9468d65">&#9670;&nbsp;</a></span>grayWorldWhiteBalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::grayWorldWhiteBalance </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>pNorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>withMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="balance_gray_world_white_8cpp_source.html#l00060">60</a> of file <a class="el" href="balance_gray_world_white_8cpp_source.html">balanceGrayWorldWhite.cpp</a>.</p>

</div>
</div>
<a id="a3c66d7da3e395731f20b961e59d2d543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c66d7da3e395731f20b961e59d2d543">&#9670;&nbsp;</a></span>isBlurred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prl::isBlurred </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="blur_detection_8cpp_source.html#l00085">85</a> of file <a class="el" href="blur_detection_8cpp_source.html">blurDetection.cpp</a>.</p>

</div>
</div>
<a id="af4a9f4e484ae7aefc5db2398ee26e487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a9f4e484ae7aefc5db2398ee26e487">&#9670;&nbsp;</a></span>isGlared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prl::isGlared </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="glare_detection_8cpp_source.html#l00027">27</a> of file <a class="el" href="glare_detection_8cpp_source.html">glareDetection.cpp</a>.</p>

</div>
</div>
<a id="ad941870f5d7cb127ae7891c87c6b1ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad941870f5d7cb127ae7891c87c6b1ff7">&#9670;&nbsp;</a></span>leptonicaToOpenCV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat prl::leptonicaToOpenCV </td>
          <td>(</td>
          <td class="paramtype">PIX *&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13586ad3476ef8e3ab7f5a1a962f2b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13586ad3476ef8e3ab7f5a1a962f2b8b">&#9670;&nbsp;</a></span>opencvToLeptonica()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pix * prl::opencvToLeptonica </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>inputImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="format_convert_8cpp_source.html#l00038">38</a> of file <a class="el" href="format_convert_8cpp_source.html">formatConvert.cpp</a>.</p>

</div>
</div>
<a id="ade2a42569bb06af854706bc67e419c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2a42569bb06af854706bc67e419c78">&#9670;&nbsp;</a></span>removeDots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::removeDots </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove dots on an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete dots on an image. </p>

<p class="definition">Definition at line <a class="el" href="remove_dots_8cpp_source.html#l00033">33</a> of file <a class="el" href="remove_dots_8cpp_source.html">removeDots.cpp</a>.</p>

</div>
</div>
<a id="a6c8a522dc3d0b900906da43eaa6d7d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8a522dc3d0b900906da43eaa6d7d24">&#9670;&nbsp;</a></span>removeHolePunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::removeHolePunch </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove hole punches on an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove hole punches on an image. Hole punch is blob near page border. </p>

<p class="definition">Definition at line <a class="el" href="remove_hole_punch_8cpp_source.html#l00034">34</a> of file <a class="el" href="remove_hole_punch_8cpp_source.html">removeHolePunch.cpp</a>.</p>

</div>
</div>
<a id="ab4c7ae723dcb243cf37200c863366dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c7ae723dcb243cf37200c863366dca">&#9670;&nbsp;</a></span>removeLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::removeLines </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove lines on an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete horizontal and vertical lines on an image. </p>

<p class="definition">Definition at line <a class="el" href="remove_lines_8cpp_source.html#l00030">30</a> of file <a class="el" href="remove_lines_8cpp_source.html">removeLines.cpp</a>.</p>

</div>
</div>
<a id="abc923b8457dccdb46d4eb54bce9b846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc923b8457dccdb46d4eb54bce9b846e">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::resize </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="resize_8cpp_source.html#l00029">29</a> of file <a class="el" href="resize_8cpp_source.html">resize.cpp</a>.</p>

</div>
</div>
<a id="a4490cacf49eae13952bdc7943d2f3404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4490cacf49eae13952bdc7943d2f3404">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void prl::rotate </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>Rotation angle</td></tr>
  </table>
  </dd>
</dl>
<p>Rotate image by provided angle. </p>

<p class="definition">Definition at line <a class="el" href="rotate_8cpp_source.html#l00035">35</a> of file <a class="el" href="rotate_8cpp_source.html">rotate.cpp</a>.</p>

</div>
</div>
<a id="a7499f593e17cb33f05fa3015b04fd368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7499f593e17cb33f05fa3015b04fd368">&#9670;&nbsp;</a></span>simpleWhiteBalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::simpleWhiteBalance </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="balance_simple_white_8cpp_source.html#l00033">33</a> of file <a class="el" href="balance_simple_white_8cpp_source.html">balanceSimpleWhite.cpp</a>.</p>

</div>
</div>
<a id="a270214848e515599d17cc9221d897540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270214848e515599d17cc9221d897540">&#9670;&nbsp;</a></span>thinGuoHall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::thinGuoHall </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Code for thinning a binary image using Guo Hall algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for processing with range = [0;255]. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting image. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thin_guo_hall_8cpp_source.html#l00056">56</a> of file <a class="el" href="thin_guo_hall_8cpp_source.html">thinGuoHall.cpp</a>.</p>

</div>
</div>
<a id="ac26b8d9e604ea2c52f2a4e9f8501f73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26b8d9e604ea2c52f2a4e9f8501f73e">&#9670;&nbsp;</a></span>thinZhangSuen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::thinZhangSuen </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Code for thinning a binary image using Zhang-Suen algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImage</td><td>Image for processing with range = [0;255]. </td></tr>
    <tr><td class="paramname">outputImage</td><td>Resulting image. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thin_zhang_suen_8cpp_source.html#l00057">57</a> of file <a class="el" href="thin_zhang_suen_8cpp_source.html">thinZhangSuen.cpp</a>.</p>

</div>
</div>
<a id="affaaa4c1c43401be979e7573ec332d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaaa4c1c43401be979e7573ec332d37">&#9670;&nbsp;</a></span>warpCrop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::warpCrop </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>borderMode</em> = <code>cv::BORDER_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Scalar &amp;&#160;</td>
          <td class="paramname"><em>borderValue</em> = <code>cv::Scalar()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform image to crop document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>Top left x coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>Top left y coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>Top right x coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>Top right y coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>Bottom right x coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>Bottom right y coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x3</td><td>Bottom left x coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y3</td><td>Bottom left y coordinate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ratio</td><td>Expected Height/Width ratio</td></tr>
  </table>
  </dd>
</dl>
<p>Crop image and do warp transformation to rectangle. Calculates aspect ratio of source image and keeps it after crop. </p>

<p class="definition">Definition at line <a class="el" href="warp_8cpp_source.html#l00032">32</a> of file <a class="el" href="warp_8cpp_source.html">warp.cpp</a>.</p>

</div>
</div>
<a id="a8c65d953915ef2871fbba97738dd514e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c65d953915ef2871fbba97738dd514e">&#9670;&nbsp;</a></span>warpCrop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::warpCrop </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em> = <code>cv::BORDER_CONSTANT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Scalar &amp;&#160;</td>
          <td class="paramname"><em>borderValue</em> = <code>cv::Scalar()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform image to crop document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputImage</td><td>Input image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputImage</td><td>Output image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Document contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ratio</td><td>Expected Height/Width ratio</td></tr>
  </table>
  </dd>
</dl>
<p>Crop image and do warp transformation to rectangle. Calculates aspect ratio of source image and keeps it after crop. </p>

<p class="definition">Definition at line <a class="el" href="warp_8cpp_source.html#l00076">76</a> of file <a class="el" href="warp_8cpp_source.html">warp.cpp</a>.</p>

</div>
</div>
<a id="ac4847e8cfe37fa1bcbf18864a4a17c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4847e8cfe37fa1bcbf18864a4a17c24">&#9670;&nbsp;</a></span>wienerFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prl::wienerFilter </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>inputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filterKernelWidth</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filterKernelHeight</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeffWiener</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaGauss</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewrite this code using OpenCV functions </p>

<p class="definition">Definition at line <a class="el" href="wiener_filter_8cpp_source.html#l00035">35</a> of file <a class="el" href="wiener_filter_8cpp_source.html">wienerFilter.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceprl.html">prl</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
