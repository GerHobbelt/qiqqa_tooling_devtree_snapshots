#/* ----------------------------------------------------------------------------
# * This file was automatically generated by SWIG (http://www.swig.org).
# * Version 3.0.12
# *
# * This file is not intended to be easily readable and contains a number of
# * coding conventions designed to improve portability and efficiency. Do not make
# * changes to this file unless you know what you are doing--modify the SWIG
# * interface file instead.
# * ----------------------------------------------------------------------------- */

from fitz_i import *

import mupdf


#----------------------------------------------------------------------------
# colorspace identifiers
#----------------------------------------------------------------------------
CS_RGB =  1
CS_GRAY = 2
CS_CMYK = 3


# General text flags
TEXT_FONT_SUPERSCRIPT = 1
TEXT_FONT_ITALIC = 2
TEXT_FONT_SERIFED = 4
TEXT_FONT_MONOSPACED = 8
TEXT_FONT_BOLD = 16


def SWIG_From_int(value):
    return int(value)


#-----------------------------------------------------------------------------
# Functions converting betwenn PySequences and fitz geometry objects
#-----------------------------------------------------------------------------
def JM_INT_ITEM(obj, idx):
    '''
    Unlike original C version, this returns the item and raises an exception if
    <idx> is out of range.

    So code liks this:
        if (JM_INT_ITEM(page_id, 1, &pno) == 1) {
            THROWMSG(gctx, "bad page id");
        }

    becomes:
        pno = JM_INT_ITEM(page_id, 1)
    '''
    if idx > len(obj):
        raise Exception(f'Bad idx={idx}, len(obj)={len(obj)}')
    return int(obj[idx])

def JM_FLOAT_ITEM(obj, idx):
    if idx > len(obj):
        raise Exception(f'Bad idx={idx}, len(obj)={len(obj)}')
    return float(obj[idx])

def PySequence_Check(r):
    return isinstance(r, (list, tuple))

def PySequence_Size(r):
    return len(r)

#-----------------------------------------------------------------------------
# PySequence to fz_rect. Default: infinite rect
#-----------------------------------------------------------------------------
def JM_rect_from_py(r):
    if not r or not PySequence_Check(r) or PySequence_Size(r) != 4:
        return Rect(Rect.Fixed_INFINITE)
    f = [0, 0, 0, 0]
    for i in range(4):
        f[i] = JM_FLOAT_ITEM(r, i)

    return mfz_make_rect(f[0], f[1], f[2], f[3])

#-----------------------------------------------------------------------------
# PySequence from fz_rect
#-----------------------------------------------------------------------------
def JM_py_from_rect(r):
    return r.x0, r.y0, r.x1, r.y1

#-----------------------------------------------------------------------------
# PySequence to fz_irect. Default: infinite irect
#-----------------------------------------------------------------------------
def JM_irect_from_py(r):
    if not PySequence_Check(r) or PySequence_Size(r) != 4:
        return fz_infinite_irect
    x = [0, 0, 0, 0]
    for i in range(4):
        x[i] = JM_INT_ITEM(r, i)

    return mfz_make_irect(x[0], x[1], x[2], x[3])

#-----------------------------------------------------------------------------
# PySequence from fz_irect
#-----------------------------------------------------------------------------
def JM_py_from_irect(r):
    return r.x0, r.y0, r.x1, r.y1


#-----------------------------------------------------------------------------
# PySequence to fz_point. Default: (0, 0)
#-----------------------------------------------------------------------------
def JM_point_from_py(p):

    p0 = mfz_make_point(0, 0)
    if not p or not PySequence_Check(p) or PySequence_Size(p) != 2:
        return p0

    x = JM_FLOAT_ITEM(p, 0)
    y = JM_FLOAT_ITEM(p, 1)

    return mfz_make_point(x, y)

#-----------------------------------------------------------------------------
# PySequence from fz_point
#-----------------------------------------------------------------------------
def JM_py_from_point(p):
    return p.x, p.y


#-----------------------------------------------------------------------------
# PySequence to fz_matrix. Default: fz_identity
#-----------------------------------------------------------------------------
def JM_matrix_from_py(m):
    if not m or not PySequence_Check(m) or PySequence_Size(m) != 6:
        return fz_identity;
    return mfz_make_matrix(m[0], m[1], m[2], m[3], m[4], m[5])

#-----------------------------------------------------------------------------
# PySequence from fz_matrix
#-----------------------------------------------------------------------------
def JM_py_from_matrix(m):
    return m.a, m.b, m.c, m.d, m.e, m.f

#-----------------------------------------------------------------------------
# fz_quad from PySequence. Four floats are treated as rect.
# Else must be four pairs of floats.
#-----------------------------------------------------------------------------
def JM_quad_from_py(r):
    q = mfz_make_quad(0, 0, 0, 0, 0, 0, 0, 0)
    p = [0, 0, 0, 0]

    if not r or not PySequence_Check(r) or PySequence_Size(r) != 4:
        return q

    try:
        test = JM_FLOAT_ITEM(r, 0)
    except Exception:
        return mfz_quad_from_rect(JM_rect_from_py(r))

    for i in range(4):
        obj = PySequence_ITEM(r, i);  # next point item
        if not obj or not PySequence_Check(obj) or PySequence_Size(obj) != 2:
            return q  # invalid: cancel the rest

        try:
            p[i].x = JM_FLOAT_ITEM(obj, 0)
            p[i].y = JM_FLOAT_ITEM(obj, 1)
        except Exception:
            return q
    q.ul = p[0];
    q.ur = p[1];
    q.ll = p[2];
    q.lr = p[3];
    return q

#-----------------------------------------------------------------------------
# PySequence from fz_quad.
#-----------------------------------------------------------------------------
def JM_py_from_quad(quad):
    return (
            JM_py_from_point(quad.ul),
            JM_py_from_point(quad.ur),
            JM_py_from_point(quad.ll),
            JM_py_from_point(quad.lr),
            )


def LIST_APPEND_DROP(list_, item):
    list_.append(item)

def DICT_SETITEM_DROP(dict_, key, value):
    dict_[key] = value

def DICT_SETITEMSTR_DROP(dict_, key, value):
    dict_[key] = value


def JM_get_page_labels(liste, nums):
    n = pdf_array_len(ctx, nums);
    for i in range(n, 2):
        key = mpdf_resolve_indirect(mpdf_array_get(nums, i))
        pno = mpdf_to_int(key)
        val = mpdf_resolve_indirect(mpdf_array_get(nums, i + 1))
        res = JM_object_to_buffer(ctx, val, 1, 0);
        c = mfz_buffer_storage(res)
        LIST_APPEND_DROP(liste, (pno, c))


def JM_EscapeStrFromBuffer(buff):
    if not buff.m_internal:
        return ''
    bytes_ = buffer_extract(buff)
    return bytes_.decode('utf-8')


def JM_UnicodeFromBuffer(buff):
    if not buff.m_internal:
        return b''
    bytes_ = buffer_extract(buff)
    return bytes_


def JM_UnicodeFromStr(c):
    return c.encode('utf-8')

def JM_EscapeStrFromStr(c):
    return c


# list of valid unicodes of a fz_font
#def JM_valid_chars(fz_font *font, void *arr):
def JM_valid_chars(font, arr):
    assert 0, 'Not implemented'
'''
{
	FT_Face face = font.m_internal.ft_face
	FT_ULong ucs;
	FT_UInt gid;
	long *table = (long *)arr;
	fz_lock(ctx, FZ_LOCK_FREETYPE);
	ucs = FT_Get_First_Char(face, &gid);
	while (gid > 0)
	{
		if (gid < (FT_ULong)face->num_glyphs && face->num_glyphs > 0)
			table[gid] = (long)ucs;
		ucs = FT_Get_Next_Char(face, ucs, &gid);
	}
	fz_unlock(ctx, FZ_LOCK_FREETYPE);
	return;
}
'''

# redirect MuPDF warnings
def JM_mupdf_warning(user, message):
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message))

def PySys_WriteStderr(text):
    sys.stderr.write(text)

def PySys_WriteStdout(text):
    sys.stdout.write(text)


# redirect MuPDF errors
def JM_mupdf_error(user, message):
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message))
    if JM_mupdf_show_errors:
        PySys_WriteStderr("mupdf: %s\n", message)


# a simple tracer
def JM_TRACE(id):
    PySys_WriteStdout("%s\n", id);


# put a warning on Python-stdout
def JM_Warning(id):
    PySys_WriteStdout("warning: %s\n", id)


#if JM_MEMORY == 1
#-----------------------------------------------------------------------------
# The following 3 functions replace MuPDF standard memory allocation.
# This will ensure, that MuPDF memory handling becomes part of Python's
# memory management.
#-----------------------------------------------------------------------------
'''
static void *JM_Py_Malloc(void *opaque, size_t size)
{
    void *mem = PyMem_Malloc((Py_ssize_t) size);
    if (mem) return mem;
    fz_throw(gctx, FZ_ERROR_MEMORY, "malloc of %zu bytes failed", size);
}

static void *JM_Py_Realloc(void *opaque, void *old, size_t size)
{
    void *mem = PyMem_Realloc(old, (Py_ssize_t) size);
    if (mem) return mem;
    fz_throw(gctx, FZ_ERROR_MEMORY, "realloc of %zu bytes failed", size);
}

static void JM_PY_Free(void *opaque, void *ptr)
{
    PyMem_Free(ptr);
}

const fz_alloc_context JM_Alloc_Context =
{
	NULL,
	JM_Py_Malloc,
	JM_Py_Realloc,
	JM_PY_Free
};
#endif
'''

# return Python bool for a given integer
def JM_BOOL(v):
    return True if v else False


'''
PyObject *JM_fitz_config()
{
#if defined(TOFU)
#define have_TOFU JM_BOOL(0)
#else
#define have_TOFU JM_BOOL(1)
#endif
#if defined(TOFU_CJK)
#define have_TOFU_CJK JM_BOOL(0)
#else
#define have_TOFU_CJK JM_BOOL(1)
#endif
#if defined(TOFU_CJK_EXT)
#define have_TOFU_CJK_EXT JM_BOOL(0)
#else
#define have_TOFU_CJK_EXT JM_BOOL(1)
#endif
#if defined(TOFU_CJK_LANG)
#define have_TOFU_CJK_LANG JM_BOOL(0)
#else
#define have_TOFU_CJK_LANG JM_BOOL(1)
#endif
#if defined(TOFU_EMOJI)
#define have_TOFU_EMOJI JM_BOOL(0)
#else
#define have_TOFU_EMOJI JM_BOOL(1)
#endif
#if defined(TOFU_HISTORIC)
#define have_TOFU_HISTORIC JM_BOOL(0)
#else
#define have_TOFU_HISTORIC JM_BOOL(1)
#endif
#if defined(TOFU_SYMBOL)
#define have_TOFU_SYMBOL JM_BOOL(0)
#else
#define have_TOFU_SYMBOL JM_BOOL(1)
#endif
#if defined(TOFU_SIL)
#define have_TOFU_SIL JM_BOOL(0)
#else
#define have_TOFU_SIL JM_BOOL(1)
#endif
#if defined(TOFU_BASE14)
#define have_TOFU_BASE14 JM_BOOL(0)
#else
#define have_TOFU_BASE14 JM_BOOL(1)
#endif
    PyObject *dict = PyDict_New();
    DICT_SETITEMSTR_DROP(dict, "plotter-g", JM_BOOL(FZ_PLOTTERS_G));
    DICT_SETITEMSTR_DROP(dict, "plotter-rgb", JM_BOOL(FZ_PLOTTERS_RGB));
    DICT_SETITEMSTR_DROP(dict, "plotter-cmyk", JM_BOOL(FZ_PLOTTERS_CMYK));
    DICT_SETITEMSTR_DROP(dict, "plotter-n", JM_BOOL(FZ_PLOTTERS_N));
    DICT_SETITEMSTR_DROP(dict, "pdf", JM_BOOL(FZ_ENABLE_PDF));
    DICT_SETITEMSTR_DROP(dict, "xps", JM_BOOL(FZ_ENABLE_XPS));
    DICT_SETITEMSTR_DROP(dict, "svg", JM_BOOL(FZ_ENABLE_SVG));
    DICT_SETITEMSTR_DROP(dict, "cbz", JM_BOOL(FZ_ENABLE_CBZ));
    DICT_SETITEMSTR_DROP(dict, "img", JM_BOOL(FZ_ENABLE_IMG));
    DICT_SETITEMSTR_DROP(dict, "html", JM_BOOL(FZ_ENABLE_HTML));
    DICT_SETITEMSTR_DROP(dict, "epub", JM_BOOL(FZ_ENABLE_EPUB));
    DICT_SETITEMSTR_DROP(dict, "jpx", JM_BOOL(FZ_ENABLE_JPX));
    DICT_SETITEMSTR_DROP(dict, "js", JM_BOOL(FZ_ENABLE_JS));
    DICT_SETITEMSTR_DROP(dict, "tofu", have_TOFU);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk", have_TOFU_CJK);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-ext", have_TOFU_CJK_EXT);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-lang", have_TOFU_CJK_LANG);
    DICT_SETITEMSTR_DROP(dict, "tofu-emoji", have_TOFU_EMOJI);
    DICT_SETITEMSTR_DROP(dict, "tofu-historic", have_TOFU_HISTORIC);
    DICT_SETITEMSTR_DROP(dict, "tofu-symbol", have_TOFU_SYMBOL);
    DICT_SETITEMSTR_DROP(dict, "tofu-sil", have_TOFU_SIL);
    DICT_SETITEMSTR_DROP(dict, "icc", JM_BOOL(FZ_ENABLE_ICC));
    DICT_SETITEMSTR_DROP(dict, "base14", have_TOFU_BASE14);
    DICT_SETITEMSTR_DROP(dict, "py-memory", JM_BOOL(JM_MEMORY));
    return dict;
}
'''

#----------------------------------------------------------------------------
# Update a color float array with values from a Python sequence.
# Any error condition is treated as a no-op.
#----------------------------------------------------------------------------
def JM_color_FromSequence(color, col):
    if not color or (not PySequence_Check(color) and not PyFloat_Check(color)):
        return 1

    if PyFloat_Check(color): # maybe just a single float
        c = float(color)
        if not INRANGE(c, 0, 1):
            return 1
        col[0] = c
        return 1

    len_ = PySequence_Size(color)
    if not INRANGE(len, 1, 4) or len_ == 2:
        return 1


    for i in range(len_):
        col[i] = color[i]
    return len_


# return extension for fitz image type
def JM_image_extension(type_):
    if type_ == FZ_IMAGE_RAW: return "raw"
    if type_ == FZ_IMAGE_FLATE: return "flate"
    if type_ == FZ_IMAGE_LZW: return "lzw"
    if type_ == FZ_IMAGE_RLD: return "rld"
    if type_ == FZ_IMAGE_BMP: return "bmp"
    if type_ == FZ_IMAGE_GIF: return "gif"
    if type_ == FZ_IMAGE_JBIG2: return "jb2"
    if type_ == FZ_IMAGE_JPEG: return "jpeg"
    if type_ == FZ_IMAGE_JPX: return "jpx"
    if type_ == FZ_IMAGE_JXR: return "jxr"
    if type_ == FZ_IMAGE_PNG: return "png"
    if type_ == FZ_IMAGE_PNM: return "pnm"
    if type_ == FZ_IMAGE_TIFF: return "tiff"
    return "n/a"


#----------------------------------------------------------------------------
# Turn fz_buffer into a Python bytes object
#----------------------------------------------------------------------------
def JM_BinFromBuffer(buffer_):
    if not buffer_.m_internal:
        return b''
    return buffer_.buffer_extract()


#----------------------------------------------------------------------------
# Turn fz_buffer into a Python bytearray object
#----------------------------------------------------------------------------
def JM_BArrayFromBuffer(buffer_):
    return bytearray(JM_BinFromBuffer(buffer_))


#----------------------------------------------------------------------------
# compress char* into a new buffer
#----------------------------------------------------------------------------
def JM_compress_buffer(inbuffer):
    compressed_data, compressed_length = mfz_new_deflated_data_from_buffer(inbuffer, FZ_DEFLATE_BEST)
    if compressed_length == 0:
        return
    buf = mfz_new_buffer_from_data(compressed_data, compressed_length)
    mfz_resize_buffer(buf, compressed_length)
    return buf


#----------------------------------------------------------------------------
# update a stream object
# compress stream when beneficial
#----------------------------------------------------------------------------
#void JM_update_stream(fz_context *ctx, pdf_document *doc, pdf_obj *obj, fz_buffer *buffer, int compress)
def JM_update_stream(doc, obj, buffer_, compress):

    len_, _ = mfz_buffer_storage(buffer_)
    nlen = len_

    if len_ > 30:   # ignore small stuff
        nres = JM_compress_buffer(buffer_)
        nlen, _ = mfz_buffer_storage(nres)

    if nlen < len_ and compress==1:    # was it worth the effort?
        mpdf_dict_put(obj, PDF_NAME(Filter), PDF_NAME(FlateDecode))
        mpdf_update_stream(doc, obj, nres, 1)
    else:
        mpdf_update_stream(doc, obj, buffer_, 0)


#-----------------------------------------------------------------------------
# return hex characters for n characters in input 'in'
#-----------------------------------------------------------------------------
def hexlify(n, in_):
    hdigit = "0123456789abcedf"
    out = ''
    for i in range(n):
        c = ord(in_[i])
        out += hdigit(c / 16)
        out += hdigit(c % 16)
    return out


#----------------------------------------------------------------------------
# Make fz_buffer from a PyBytes, PyByteArray, io.BytesIO object
#----------------------------------------------------------------------------
#fz_buffer *JM_BufferFromBytes(fz_context *ctx, PyObject *stream)
def JM_BufferFromBytes(stream):

    if not stream:
        return None
    if isinstance(stream, bytes):
        res = mfz_new_buffer_from_copied_data(python_bytes_data(stream), len(stream))
        return res
    assert 0, f'Not implemented type(stream)={type(stream)}'
    '''
    char *c = NULL;
    PyObject *mybytes = NULL;
    size_t len = 0;
    fz_buffer *res = NULL;
    fz_var(res);
    fz_try(ctx) {
        if (PyBytes_Check(stream)) {
            c = PyBytes_AS_STRING(stream);
            len = (size_t) PyBytes_GET_SIZE(stream);
        } else if (PyByteArray_Check(stream)) {
            c = PyByteArray_AS_STRING(stream);
            len = (size_t) PyByteArray_GET_SIZE(stream);
        } else if (PyObject_HasAttrString(stream, "getvalue")) {
            // we assume here that this delivers what we expect
            mybytes = PyObject_CallMethod(stream, "getvalue", NULL);
            c = PyBytes_AS_STRING(mybytes);
            len = (size_t) PyBytes_GET_SIZE(mybytes);
        }
        // all the above leave c as NULL pointer if unsuccessful
        if (c) res = fz_new_buffer_from_copied_data(ctx, (const unsigned char *) c, len);
    }
    fz_always(ctx) {
        Py_CLEAR(mybytes);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_drop_buffer(ctx, res);
        fz_rethrow(ctx);
    }
    return res;
    '''


##----------------------------------------------------------------------------
## Deep-copies a specified source page to the target location.
## Modified copy of function of pdfmerge.c: we also copy annotations, but
## we skip **link** annotations. In addition we rotate output.
##----------------------------------------------------------------------------
#static void
#page_merge(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int page_from, int page_to, int #rotate, int links, int copy_annots, pdf_graft_map *graft_map)
#{
#    pdf_obj *page_ref = NULL;
#    pdf_obj *page_dict = NULL;
#    pdf_obj *obj = NULL, *ref = NULL;
#
#    // list of object types (per page) we want to copy
#    pdf_obj *known_page_objs[] = {
#        PDF_NAME(Contents),
#        PDF_NAME(Resources),
#        PDF_NAME(MediaBox),
#        PDF_NAME(CropBox),
#        PDF_NAME(BleedBox),
#        PDF_NAME(TrimBox),
#        PDF_NAME(ArtBox),
#        PDF_NAME(Rotate),
#        PDF_NAME(UserUnit)
#    };
#    int i, n = (int) nelem(known_page_objs);  // number of list elements
#    fz_var(ref);
#    fz_var(page_dict);
#    fz_try(ctx) {
#        page_ref = pdf_lookup_page_obj(ctx, doc_src, page_from);
#        pdf_flatten_inheritable_page_items(ctx, page_ref);
#
#        // make new page dict in dest doc
#        page_dict = pdf_new_dict(ctx, doc_des, 4);
#        pdf_dict_put(ctx, page_dict, PDF_NAME(Type), PDF_NAME(Page));
#
#        // copy objects of source page into it
#        for (i = 0; i < n; i++) {
#            obj = pdf_dict_get(ctx, page_ref, known_page_objs[i]);
#            if (obj != NULL) {
#                pdf_dict_put_drop(ctx, page_dict, known_page_objs[i], pdf_graft_mapped_object(ctx, #graft_map, obj));
#            }
#        }
#
#        // Copy the annotations, but skip types Link, Popup, IRT.
#        // Remove dict keys P (parent) and Popup from copied annot.
#        if (copy_annots) {
#            pdf_obj *old_annots = pdf_dict_get(ctx, page_ref, PDF_NAME(Annots));
#            if (old_annots) {
#                n = pdf_array_len(ctx, old_annots);
#                pdf_obj *new_annots = pdf_dict_put_array(ctx, page_dict, PDF_NAME(Annots), n);
#                for (i = 0; i < n; i++) {
#                    pdf_obj *o = pdf_array_get(ctx, old_annots, i);
#                    if (pdf_dict_gets(ctx, o, "IRT")) continue;
#                    pdf_obj *subtype = pdf_dict_get(ctx, o, PDF_NAME(Subtype));
#                    if (pdf_name_eq(ctx, subtype, PDF_NAME(Link))) continue;
#                    if (pdf_name_eq(ctx, subtype, PDF_NAME(Popup))) continue;
#                    pdf_dict_del(ctx, o, PDF_NAME(Popup));
#                    pdf_dict_del(ctx, o, PDF_NAME(P));
#                    pdf_obj *copy_o = pdf_graft_mapped_object(ctx, graft_map, o);
#                    pdf_obj *annot = pdf_new_indirect(ctx, doc_des,
#                                     pdf_to_num(ctx, copy_o), 0);
#                    pdf_array_push_drop(ctx, new_annots, annot);
#                    pdf_drop_obj(ctx, copy_o);
#                }
#            }
#        }
#        // rotate the page
#        if (rotate != -1) {
#            pdf_dict_put_int(ctx, page_dict, PDF_NAME(Rotate), (int64_t) rotate);
#        }
#        // Now add the page dictionary to dest PDF
#        ref = pdf_add_object(ctx, doc_des, page_dict);
#
#        // Insert new page at specified location
#        pdf_insert_page(ctx, doc_des, page_to, ref);
#
#    }
#    fz_always(ctx) {
#        pdf_drop_obj(ctx, ref);
#        pdf_drop_obj(ctx, page_dict);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
##-----------------------------------------------------------------------------
## Copy a range of pages (spage, epage) from a source PDF to a specified
## location (apage) of the target PDF.
## If spage > epage, the sequence of source pages is reversed.
##-----------------------------------------------------------------------------
#void JM_merge_range(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int spage, int epage, #int apage, int rotate, int links, int annots, int show_progress, pdf_graft_map *graft_map)
#{
#    int page, afterpage;
#    afterpage = apage;
#    int counter = 0;  // copied pages counter
#    int total = fz_absi(epage - spage) + 1;  // total pages to copy
#
#    fz_try(ctx) {
#        if (spage < epage) {
#            for (page = spage; page <= epage; page++, afterpage++) {
#                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
#                counter++;
#                if (show_progress > 0 && counter % show_progress == 0) {
#                    PySys_WriteStdout("Inserted %i of %i pages.\n", counter, total);
#                }
#            }
#        } else {
#            for (page = spage; page >= epage; page--, afterpage++) {
#                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
#                counter++;
#                if (show_progress > 0 && counter % show_progress == 0) {
#                    PySys_WriteStdout("Inserted %i of %i pages.\n", counter, total);
#                }
#            }
#        }
#    }
#
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
##----------------------------------------------------------------------------
## Return list of outline xref numbers. Recursive function. Arguments:
## 'obj' first OL item
## 'xrefs' empty Python list
##----------------------------------------------------------------------------
#PyObject *JM_outline_xrefs(fz_context *ctx, pdf_obj *obj, PyObject *xrefs)
#{
#    pdf_obj *first, *parent, *thisobj;
#    if (!obj) return xrefs;
#    thisobj = obj;
#    while (thisobj) {
#        LIST_APPEND_DROP(xrefs, Py_BuildValue("i", pdf_to_num(ctx, thisobj)));
#        first = pdf_dict_get(ctx, thisobj, PDF_NAME(First));  // try go down
#        if (first) xrefs = JM_outline_xrefs(ctx, first, xrefs);
#        thisobj = pdf_dict_get(ctx, thisobj, PDF_NAME(Next));  // try go next
#        parent = pdf_dict_get(ctx, thisobj, PDF_NAME(Parent));  // get parent
#        if (!thisobj) thisobj = parent;  // goto parent if no next
#    }
#    return xrefs;
#}
#
#
##-----------------------------------------------------------------------------
## Return the contents of a font file, identified by xref
##-----------------------------------------------------------------------------
#fz_buffer *JM_get_fontbuffer(fz_context *ctx, pdf_document *doc, int xref)
#{
#    if (xref < 1) return NULL;
#    pdf_obj *o, *obj = NULL, *desft, *stream = NULL;
#    o = pdf_load_object(ctx, doc, xref);
#    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
#    char *ext = NULL;
#    if (desft) {
#        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
#        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
#    } else {
#        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));
#    }
#
#    if (!obj) {
#        pdf_drop_obj(ctx, o);
#        PySys_WriteStdout("invalid font - FontDescriptor missing");
#        return NULL;
#    }
#    pdf_drop_obj(ctx, o);
#    o = obj;
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
#    if (obj) stream = obj;             // ext = "pfa"
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
#    if (obj) stream = obj;             // ext = "ttf"
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
#    if (obj) {
#        stream = obj;
#
#        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
#        if (obj && !pdf_is_name(ctx, obj)) {
#            PySys_WriteStdout("invalid font descriptor subtype");
#            return NULL;
#        }
#
#        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
#            ext = "cff";
#        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
#            ext = "cid";
#        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
#            ext = "otf";
#        else
#            PySys_WriteStdout("warning: unhandled font type '%s'", pdf_to_name(ctx, obj));
#    }
#
#    if (!stream) {
#        PySys_WriteStdout("warning: unhandled font type");
#        return NULL;
#    }
#
#    return pdf_load_stream(ctx, stream);
#}
#
##-----------------------------------------------------------------------------
## Return the file extension of a font file, identified by xref
##-----------------------------------------------------------------------------
#char *JM_get_fontextension(fz_context *ctx, pdf_document *doc, int xref)
#{
#    if (xref < 1) return "n/a";
#    pdf_obj *o, *obj = NULL, *desft;
#    o = pdf_load_object(ctx, doc, xref);
#    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
#    if (desft) {
#        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
#        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
#    } else {
#        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));
#    }
#
#    pdf_drop_obj(ctx, o);
#    if (!obj) return "n/a";           // this is a base-14 font
#
#    o = obj;                           // we have the FontDescriptor
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
#    if (obj) return "pfa";
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
#    if (obj) return "ttf";
#
#    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
#    if (obj) {
#        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
#        if (obj && !pdf_is_name(ctx, obj)) {
#            PySys_WriteStdout("invalid font descriptor subtype");
#            return "n/a";
#        }
#        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
#            return "cff";
#        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
#            return "cid";
#        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
#            return "otf";
#        else
#            PySys_WriteStdout("unhandled font type '%s'", pdf_to_name(ctx, obj));
#    }
#
#    return "n/a";
#}
#
#
##-----------------------------------------------------------------------------
## create PDF object from given string (new in v1.14.0: MuPDF dropped it)
##-----------------------------------------------------------------------------
#pdf_obj *JM_pdf_obj_from_str(fz_context *ctx, pdf_document *doc, char *src)
#{
#    pdf_obj *result = NULL;
#    pdf_lexbuf lexbuf;
#    fz_stream *stream = fz_open_memory(ctx, (unsigned char *)src, strlen(src));
#
#    pdf_lexbuf_init(ctx, &lexbuf, PDF_LEXBUF_SMALL);
#
#    fz_try(ctx) {
#        result = pdf_parse_stm_obj(ctx, doc, stream, &lexbuf);
#    }
#
#    fz_always(ctx) {
#        pdf_lexbuf_fin(ctx, &lexbuf);
#        fz_drop_stream(ctx, stream);
#    }
#
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#
#    return result;
#
#}
#
##----------------------------------------------------------------------------
## return normalized /Rotate value
##----------------------------------------------------------------------------
#int JM_norm_rotation(int rotate)
#{
#    while (rotate < 0) rotate += 360;
#    while (rotate >= 360) rotate -= 360;
#    if (rotate % 90 != 0) return 0;
#    return rotate;
#}
#
#
##----------------------------------------------------------------------------
## return a PDF page's /Rotate value: one of (0, 90, 180, 270)
##----------------------------------------------------------------------------
#int JM_page_rotation(fz_context *ctx, pdf_page *page)
#{
#    int rotate = 0;
#    fz_try(ctx)
#    {
#        rotate = pdf_to_int(ctx,
#                pdf_dict_get_inheritable(ctx, page->obj, PDF_NAME(Rotate)));
#        rotate = JM_norm_rotation(rotate);
#    }
#    fz_catch(ctx) return 0;
#    return rotate;
#}
#
#
##----------------------------------------------------------------------------
## return a PDF page's MediaBox
##----------------------------------------------------------------------------
#fz_rect JM_mediabox(fz_context *ctx, pdf_obj *page_obj)
#{
#    fz_rect mediabox, page_mediabox;
#
#    mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, page_obj,
#        PDF_NAME(MediaBox)));
#    if (fz_is_empty_rect(mediabox) or fz_is_infinite_rect(mediabox))
#    {
#        mediabox.x0 = 0;
#        mediabox.y0 = 0;
#        mediabox.x1 = 612;
#        mediabox.y1 = 792;
#    }
#
#    page_mediabox.x0 = fz_min(mediabox.x0, mediabox.x1);
#    page_mediabox.y0 = fz_min(mediabox.y0, mediabox.y1);
#    page_mediabox.x1 = fz_max(mediabox.x0, mediabox.x1);
#    page_mediabox.y1 = fz_max(mediabox.y0, mediabox.y1);
#
#    if (page_mediabox.x1 - page_mediabox.x0 < 1 ||
#        page_mediabox.y1 - page_mediabox.y0 < 1)
#        page_mediabox = fz_unit_rect;
#
#    return page_mediabox;
#}
#
#
##----------------------------------------------------------------------------
## return a PDF page's CropBox
##----------------------------------------------------------------------------
#fz_rect JM_cropbox(fz_context *ctx, pdf_obj *page_obj)
#{
#    fz_rect mediabox = JM_mediabox(ctx, page_obj);
#    fz_rect cropbox = pdf_to_rect(ctx,
#                pdf_dict_get_inheritable(ctx, page_obj, PDF_NAME(CropBox)));
#    if (fz_is_infinite_rect(cropbox) or fz_is_empty_rect(cropbox))
#        return mediabox;
#    float y0 = mediabox.y1 - cropbox.y1;
#    float y1 = mediabox.y1 - cropbox.y0;
#    cropbox.y0 = y0;
#    cropbox.y1 = y1;
#    return cropbox;
#}
#
#
##----------------------------------------------------------------------------
## calculate width and height of the UNROTATED page
##----------------------------------------------------------------------------
#fz_point JM_cropbox_size(fz_context *ctx, pdf_obj *page_obj)
#{
#    fz_point size;
#    fz_try(ctx)
#    {
#        fz_rect rect = JM_cropbox(ctx, page_obj);
#        float w = (rect.x0 < rect.x1 ? rect.x1 - rect.x0 : rect.x0 - rect.x1);
#        float h = (rect.y0 < rect.y1 ? rect.y1 - rect.y0 : rect.y0 - rect.y1);
#        size = fz_make_point(w, h);
#    }
#    fz_catch(ctx) fz_rethrow(ctx);
#    return size;
#}
#
#
##----------------------------------------------------------------------------
## calculate page rotation matrices
##----------------------------------------------------------------------------
#fz_matrix JM_rotate_page_matrix(fz_context *ctx, pdf_page *page)
#{
#    if (!page) return fz_identity;  // no valid pdf page given
#    int rotation = JM_page_rotation(ctx, page);
#    if (rotation == 0) return fz_identity;  // no rotation
#    fz_matrix m;
#    fz_point cb_size = JM_cropbox_size(ctx, page->obj);
#    float w = cb_size.x;
#    float h = cb_size.y;
#    if (rotation == 90)
#        m = fz_make_matrix(0, 1, -1, 0, h, 0);
#    else if (rotation == 180)
#        m = fz_make_matrix(-1, 0, 0, -1, w, h);
#    else
#        m = fz_make_matrix(0, -1, 1, 0, 0, w);
#    return m;
#}
#
#
#fz_matrix JM_derotate_page_matrix(fz_context *ctx, pdf_page *page)
#{  // just the inverse of rotation
#    return fz_invert_matrix(JM_rotate_page_matrix(ctx, page));
#}
#
#
##-----------------------------------------------------------------------------
## dummy structure for various tools and utilities
##-----------------------------------------------------------------------------
#struct Tools {int index;};
#
#typedef struct fz_item fz_item;
#
#struct fz_item
#{
#	void *key;
#	fz_storable *val;
#	size_t size;
#	fz_item *next;
#	fz_item *prev;
#	fz_store *store;
#	const fz_store_type *type;
#};
#
#struct fz_store
#{
#	int refs;
#
#	/* Every item in the store is kept in a doubly linked list, ordered
#	 * by usage (so LRU entries are at the end). */
#	fz_item *head;
#	fz_item *tail;
#
#	/* We have a hash table that allows to quickly find a subset of the
#	 * entries (those whose keys are indirect objects). */
#	fz_hash_table *hash;
#
#	/* We keep track of the size of the store, and keep it below max. */
#	size_t max;
#	size_t size;
#
#	int defer_reap_count;
#	int needs_reaping;
#};
#
#
#
#
##-----------------------------------------------------------------------------
## pixmap helper functions
##-----------------------------------------------------------------------------
#
##-----------------------------------------------------------------------------
## Clear a pixmap rectangle - my version also supports non-alpha pixmaps
##-----------------------------------------------------------------------------
#int
#JM_clear_pixmap_rect_with_value(fz_context *ctx, fz_pixmap *dest, int value, fz_irect b)
#{
#    unsigned char *destp;
#    int x, y, w, k, destspan;
#
#    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
#    w = b.x1 - b.x0;
#    y = b.y1 - b.y0;
#    if (w <= 0 or y <= 0)
#        return 0;
#
#    destspan = dest->stride;
#    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));
#
#    /* CMYK needs special handling (and potentially any other subtractive colorspaces) */
#    if (fz_colorspace_n(ctx, dest->colorspace) == 4) {
#        value = 255 - value;
#        do {
#            unsigned char *s = destp;
#            for (x = 0; x < w; x++) {
#                *s++ = 0;
#                *s++ = 0;
#                *s++ = 0;
#                *s++ = value;
#                if (dest->alpha) *s++ = 255;
#            }
#            destp += destspan;
#        } while (--y);
#        return 1;
#    }
#
#    do {
#        unsigned char *s = destp;
#        for (x = 0; x < w; x++) {
#            for (k = 0; k < dest->n - 1; k++)
#                *s++ = value;
#            if (dest->alpha) *s++ = 255;
#            else *s++ = value;
#        }
#        destp += destspan;
#    } while (--y);
#    return 1;
#}
#
##-----------------------------------------------------------------------------
## fill a rect with a color tuple
##-----------------------------------------------------------------------------
#int
#JM_fill_pixmap_rect_with_color(fz_context *ctx, fz_pixmap *dest, unsigned char col[5], fz_irect b)
#{
#    unsigned char *destp;
#    int x, y, w, i, destspan;
#
#    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
#    w = b.x1 - b.x0;
#    y = b.y1 - b.y0;
#    if (w <= 0 or y <= 0)
#        return 0;
#
#    destspan = dest->stride;
#    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));
#
#    do {
#        unsigned char *s = destp;
#        for (x = 0; x < w; x++) {
#            for (i = 0; i < dest->n; i++)
#                *s++ = col[i];
#        }
#        destp += destspan;
#    } while (--y);
#    return 1;
#}
#
##-----------------------------------------------------------------------------
## invert a rectangle - also supports non-alpha pixmaps
##-----------------------------------------------------------------------------
#int
#JM_invert_pixmap_rect(fz_context *ctx, fz_pixmap *dest, fz_irect b)
#{
#    unsigned char *destp;
#    int x, y, w, i, destspan;
#
#    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
#    w = b.x1 - b.x0;
#    y = b.y1 - b.y0;
#    if (w <= 0 or y <= 0)
#        return 0;
#
#    destspan = dest->stride;
#    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));
#    int n0 = dest->n - dest->alpha;
#    do {
#        unsigned char *s = destp;
#        for (x = 0; x < w; x++) {
#            for (i = 0; i < n0; i++)
#                *s++ = 255 - *s;
#            if (dest->alpha) *s++;
#        }
#        destp += destspan;
#    } while (--y);
#    return 1;
#}
#
#int
#JM_is_jbig2_image(fz_context *ctx, pdf_obj *dict)
#{
#	return 0;
#    pdf_obj *filter;
#	int i, n;
#
#	filter = pdf_dict_get(ctx, dict, PDF_NAME(Filter));
#	if (pdf_name_eq(ctx, filter, PDF_NAME(JBIG2Decode)))
#		return 1;
#	n = pdf_array_len(ctx, filter);
#	for (i = 0; i < n; i++)
#		if (pdf_name_eq(ctx, pdf_array_get(ctx, filter, i), PDF_NAME(JBIG2Decode)))
#			return 1;
#	return 0;
#}
#
##-----------------------------------------------------------------------------
## Return basic properties of an image provided as bytes or bytearray
## The function creates an fz_image and optionally returns it.
##-----------------------------------------------------------------------------
#PyObject *JM_image_profile(fz_context *ctx, PyObject *imagedata, int keep_image)
#{
#    if (!EXISTS(imagedata)) {
#        Py_RETURN_NONE;  // nothing given
#    }
#    fz_image *image = NULL;
#    fz_buffer *res = NULL;
#    PyObject *result = NULL;
#    unsigned char *c = NULL;
#    Py_ssize_t len = 0;
#    if (PyBytes_Check(imagedata)) {
#        c = PyBytes_AS_STRING(imagedata);
#        len = PyBytes_GET_SIZE(imagedata);
#    } else if (PyByteArray_Check(imagedata)) {
#        c = PyByteArray_AS_STRING(imagedata);
#        len = PyByteArray_GET_SIZE(imagedata);
#    } else {
#        PySys_WriteStderr("bad image data\n");
#        Py_RETURN_NONE;
#    }
#
#    if (len < 8) {
#        PySys_WriteStderr("bad image data\n");
#        Py_RETURN_NONE;
#    }
#    int type = fz_recognize_image_format(ctx, c);
#    if (type == FZ_IMAGE_UNKNOWN) {
#        Py_RETURN_NONE;
#    }
#
#    fz_try(ctx) {
#        if (keep_image) {
#            res = fz_new_buffer_from_copied_data(ctx, c, (size_t) len);
#        } else {
#            res = fz_new_buffer_from_shared_data(ctx, c, (size_t) len);
#        }
#        image = fz_new_image_from_buffer(ctx, res);
#        int xres, yres;
#        fz_image_resolution(image, &xres, &yres);
#        const char *cs_name = fz_colorspace_name(gctx, image->colorspace);
#        result = PyDict_New();
#        DICT_SETITEM_DROP(result, dictkey_width,
#                Py_BuildValue("i", image->w));
#        DICT_SETITEM_DROP(result, dictkey_height,
#                Py_BuildValue("i", image->h));
#        DICT_SETITEM_DROP(result, dictkey_xres,
#                Py_BuildValue("i", xres));
#        DICT_SETITEM_DROP(result, dictkey_yres,
#                Py_BuildValue("i", yres));
#        DICT_SETITEM_DROP(result, dictkey_colorspace,
#                Py_BuildValue("i", image->n));
#        DICT_SETITEM_DROP(result, dictkey_bpc,
#                Py_BuildValue("i", image->bpc));
#        DICT_SETITEM_DROP(result, dictkey_ext,
#                Py_BuildValue("s", JM_image_extension(type)));
#        DICT_SETITEM_DROP(result, dictkey_cs_name,
#                Py_BuildValue("s", cs_name));
#
#        if (keep_image) {
#            DICT_SETITEM_DROP(result, dictkey_image,
#                    PyLong_FromVoidPtr((void *) fz_keep_image(ctx, image)));
#        }
#    }
#    fz_always(ctx) {
#        if (!keep_image) {
#            fz_drop_image(ctx, image);
#        } else {
#            fz_drop_buffer(ctx, res);  // drop the buffer copy
#        }
#    }
#    fz_catch(ctx) {
#        Py_CLEAR(result);
#        fz_rethrow(ctx);
#    }
#    PyErr_Clear();
#    return result;
#}
#
##----------------------------------------------------------------------------
## Version of fz_new_pixmap_from_display_list (util.c) to also support
## rendering of only the 'clip' part of the displaylist rectangle
##----------------------------------------------------------------------------
#fz_pixmap *
#JM_pixmap_from_display_list(fz_context *ctx,
#                            fz_display_list *list,
#                            PyObject *ctm,
#                            fz_colorspace *cs,
#                            int alpha,
#                            PyObject *clip,
#                            fz_separations *seps
#                           )
#{
#    fz_rect rect = fz_bound_display_list(ctx, list);
#    fz_matrix matrix = JM_matrix_from_py(ctm);
#    fz_pixmap *pix = NULL;
#    fz_var(pix);
#    fz_device *dev = NULL;
#    fz_var(dev);
#    fz_rect rclip = JM_rect_from_py(clip);
#    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given
#
#    rect = fz_transform_rect(rect, matrix);
#    fz_irect irect = fz_round_rect(rect);
#
#    pix = fz_new_pixmap_with_bbox(ctx, cs, irect, seps, alpha);
#    if (alpha)
#        fz_clear_pixmap(ctx, pix);
#    else
#        fz_clear_pixmap_with_value(ctx, pix, 0xFF);
#
#    fz_try(ctx) {
#        if (!fz_is_infinite_rect(rclip)) {
#            dev = fz_new_draw_device_with_bbox(ctx, matrix, pix, &irect);
#            fz_run_display_list(ctx, list, dev, fz_identity, rclip, NULL);
#        } else {
#            dev = fz_new_draw_device(ctx, matrix, pix);
#            fz_run_display_list(ctx, list, dev, fz_identity, fz_infinite_rect, NULL);
#        }
#
#        fz_close_device(ctx, dev);
#    }
#    fz_always(ctx) {
#        fz_drop_device(ctx, dev);
#    }
#    fz_catch(ctx) {
#        fz_drop_pixmap(ctx, pix);
#        fz_rethrow(ctx);
#    }
#    return pix;
#}
#
##----------------------------------------------------------------------------
## Pixmap creation directly using a short-lived displaylist, so we can support
## separations.
##----------------------------------------------------------------------------
#fz_pixmap *
#JM_pixmap_from_page(fz_context *ctx,
#                    fz_document *doc,
#                    fz_page *page,
#                    PyObject *ctm,
#                    fz_colorspace *cs,
#                    int alpha,
#                    int annots,
#                    PyObject *clip
#                   )
#{
#    enum { SPOTS_NONE, SPOTS_OVERPRINT_SIM, SPOTS_FULL };
#    int spots;
#    if (FZ_ENABLE_SPOT_RENDERING)
#        spots = SPOTS_OVERPRINT_SIM;
#    else
#        spots = SPOTS_NONE;
#
#    fz_separations *seps = NULL;
#    fz_pixmap *pix = NULL;
#    fz_colorspace *oi = NULL;
#    fz_var(oi);
#    fz_colorspace *colorspace = cs;
#    fz_rect rect;
#    fz_irect bbox;
#    fz_device *dev = NULL;
#    fz_var(dev);
#    fz_matrix matrix = JM_matrix_from_py(ctm);
#    rect = fz_bound_page(ctx, page);
#    fz_rect rclip = JM_rect_from_py(clip);
#    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given
#    rect = fz_transform_rect(rect, matrix);
#    bbox = fz_round_rect(rect);
#
#    fz_try(ctx) {
#        // Pixmap of the document's /OutputIntents ("output intents")
#        oi = fz_document_output_intent(ctx, doc);
#        // if present and compatible, use it instead of the parameter
#        if (oi) {
#            if (fz_colorspace_n(ctx, oi) == fz_colorspace_n(ctx, cs)) {
#                colorspace = fz_keep_colorspace(ctx, oi);
#            }
#        }
#
#        // check if spots rendering is available and if so use separations
#        if (spots != SPOTS_NONE) {
#            seps = fz_page_separations(ctx, page);
#            if (seps) {
#                int i, n = fz_count_separations(ctx, seps);
#                if (spots == SPOTS_FULL)
#                    for (i = 0; i < n; i++)
#                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_SPOT);
#                else
#                    for (i = 0; i < n; i++)
#                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_COMPOSITE);
#            } else if (fz_page_uses_overprint(ctx, page)) {
#                /* This page uses overprint, so we need an empty
#                 * sep object to force the overprint simulation on. */
#                seps = fz_new_separations(ctx, 0);
#            } else if (oi && fz_colorspace_n(ctx, oi) != fz_colorspace_n(ctx, colorspace)) {
#                /* We have an output intent, and it's incompatible
#                 * with the colorspace our device needs. Force the
#                 * overprint simulation on, because this ensures that
#                 * we 'simulate' the output intent too. */
#                seps = fz_new_separations(ctx, 0);
#            }
#        }
#
#        pix = fz_new_pixmap_with_bbox(ctx, colorspace, bbox, seps, alpha);
#
#        if (alpha) {
#            fz_clear_pixmap(ctx, pix);
#        } else {
#            fz_clear_pixmap_with_value(ctx, pix, 0xFF);
#        }
#
#        dev = fz_new_draw_device(ctx, matrix, pix);
#        if (annots) {
#            fz_run_page(ctx, page, dev, fz_identity, NULL);
#        } else {
#            fz_run_page_contents(ctx, page, dev, fz_identity, NULL);
#        }
#        fz_close_device(ctx, dev);
#    }
#    fz_always(ctx) {
#        fz_drop_device(ctx, dev);
#        fz_drop_separations(ctx, seps);
#        fz_drop_colorspace(ctx, oi);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return pix;
#}
#
#
##------------------------------------------------------------------------
## return pdf_obj "border style" from Python str
##------------------------------------------------------------------------
#pdf_obj *JM_get_border_style(fz_context *ctx, PyObject *style)
#{
#    pdf_obj *val = PDF_NAME(S);
#    if (!style) return val;
#    char *s = JM_StrAsChar(style);
#    JM_PyErr_Clear;
#    if (!s) return val;
#    if      (!strncmp(s, "b", 1) or !strncmp(s, "B", 1)) val = PDF_NAME(B);
#    else if (!strncmp(s, "d", 1) or !strncmp(s, "D", 1)) val = PDF_NAME(D);
#    else if (!strncmp(s, "i", 1) or !strncmp(s, "I", 1)) val = PDF_NAME(I);
#    else if (!strncmp(s, "u", 1) or !strncmp(s, "U", 1)) val = PDF_NAME(U);
#    return val;
#}
#
##------------------------------------------------------------------------
## Make /DA string of annotation
##------------------------------------------------------------------------
#const char *JM_expand_fname(const char **name)
#{
#    if (!*name) return "Helv";
#    if (!strncmp(*name, "Co", 2)) return "Cour";
#    if (!strncmp(*name, "co", 2)) return "Cour";
#    if (!strncmp(*name, "Ti", 2)) return "TiRo";
#    if (!strncmp(*name, "ti", 2)) return "TiRo";
#    if (!strncmp(*name, "Sy", 2)) return "Symb";
#    if (!strncmp(*name, "sy", 2)) return "Symb";
#    if (!strncmp(*name, "Za", 2)) return "ZaDb";
#    if (!strncmp(*name, "za", 2)) return "ZaDb";
#    return "Helv";
#}
#
#void JM_make_annot_DA(fz_context *ctx, pdf_annot *annot, int ncol, float col[4], const char *fontname, #float fontsize)
#{
#    fz_buffer *buf = NULL;
#    fz_try(ctx)
#    {
#        buf = fz_new_buffer(ctx, 50);
#       if (ncol == 1)
#            fz_append_printf(ctx, buf, "%g g ", col[0]);
#        else if (ncol == 3)
#            fz_append_printf(ctx, buf, "%g %g %g rg ", col[0], col[1], col[2]);
#        else
#            fz_append_printf(ctx, buf, "%g %g %g %g k ", col[0], col[1], col[2], col[3]);
#        fz_append_printf(ctx, buf, "/%s %g Tf", JM_expand_fname(&fontname), fontsize);
#        unsigned char *da = NULL;
#        size_t len = fz_buffer_storage(ctx, buf, &da);
#        pdf_dict_put_string(ctx, annot->obj, PDF_NAME(DA), (const char *) da, len);
#    }
#    fz_always(ctx) fz_drop_buffer(ctx, buf);
#    fz_catch(ctx) fz_rethrow(ctx);
#    return;
#}
#
##------------------------------------------------------------------------
## refreshes the link and annotation tables of a page
##------------------------------------------------------------------------
#void JM_refresh_link_table(fz_context *ctx, pdf_page *page)
#{
#    fz_try(ctx)
#    {
#        pdf_obj *annots_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
#        if (annots_arr) {
#            fz_rect page_mediabox;
#            fz_matrix page_ctm;
#            pdf_page_transform(ctx, page, &page_mediabox, &page_ctm);
#            page->links = pdf_load_link_annots(ctx, page->doc, annots_arr,
#                                            pdf_to_num(ctx, page->obj), page_ctm);
#            pdf_load_annots(ctx, page, annots_arr);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return;
#}
#
#
#PyObject *JM_annot_border(fz_context *ctx, pdf_obj *annot_obj)
#{
#    PyObject *res = PyDict_New();
#    PyObject *dash_py   = PyList_New(0);
#    PyObject *effect_py = PyList_New(0);
#    PyObject *val;
#    int i;
#    char *effect2 = NULL, *style = NULL;
#    float width = -1.0f;
#    int effect1 = -1;
#
#    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(Border));
#    if (pdf_is_array(ctx, o)) {
#        width = pdf_to_real(ctx, pdf_array_get(ctx, o, 2));
#        if (pdf_array_len(ctx, o) == 4) {
#            pdf_obj *dash = pdf_array_get(ctx, o, 3);
#            for (i = 0; i < pdf_array_len(ctx, dash); i++) {
#                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, dash, i)));
#                LIST_APPEND_DROP(dash_py, val);
#            }
#        }
#    }
#
#    pdf_obj *bs_o = pdf_dict_get(ctx, annot_obj, PDF_NAME(BS));
#    if (bs_o)
#    {
#        o = pdf_dict_get(ctx, bs_o, PDF_NAME(W));
#        if (o) width = pdf_to_real(ctx, o);
#        o = pdf_dict_get(ctx, bs_o, PDF_NAME(S));
#        if (o) style = (char *) pdf_to_name(ctx, o);
#        o = pdf_dict_get(ctx, bs_o, PDF_NAME(D));
#        if (o) {
#            for (i = 0; i < pdf_array_len(ctx, o); i++) {
#                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, o, i)));
#                LIST_APPEND_DROP(dash_py, val);
#            }
#        }
#    }
#
#    pdf_obj *be_o = pdf_dict_gets(ctx, annot_obj, "BE");
#    if (be_o) {
#        o = pdf_dict_get(ctx, be_o, PDF_NAME(S));
#        if (o) effect2 = (char *) pdf_to_name(ctx, o);
#        o = pdf_dict_get(ctx, be_o, PDF_NAME(I));
#        if (o) effect1 = pdf_to_int(ctx, o);
#    }
#
#    LIST_APPEND_DROP(effect_py, Py_BuildValue("i", effect1));
#    LIST_APPEND_DROP(effect_py, Py_BuildValue("s", effect2));
#    DICT_SETITEM_DROP(res, dictkey_width, Py_BuildValue("f", width));
#    DICT_SETITEM_DROP(res, dictkey_dashes, dash_py);
#    DICT_SETITEM_DROP(res, dictkey_style, Py_BuildValue("s", style));
#    if (effect1 > -1) PyDict_SetItem(res, dictkey_effect, effect_py);
#    Py_CLEAR(effect_py);
#    return res;
#}
#
#PyObject *JM_annot_set_border(fz_context *ctx, PyObject *border, pdf_document *doc, pdf_obj *annot_obj)
#{
#    if (!PyDict_Check(border)) {
#        JM_Warning("arg must be a dict");
#        Py_RETURN_NONE;     // not a dict
#    }
#
#    double nwidth = -1;                       // new width
#    double owidth = -1;                       // old width
#    PyObject *ndashes = NULL;                 // new dashes
#    PyObject *odashes = NULL;                 // old dashes
#    PyObject *nstyle  = NULL;                 // new style
#    PyObject *ostyle  = NULL;                 // old style
#
#    nwidth = PyFloat_AsDouble(PyDict_GetItem(border, dictkey_width));
#    ndashes = PyDict_GetItem(border, dictkey_dashes);
#    nstyle  = PyDict_GetItem(border, dictkey_style);
#
#    // first get old border properties
#    PyObject *oborder = JM_annot_border(ctx, annot_obj);
#    owidth = PyFloat_AsDouble(PyDict_GetItem(oborder, dictkey_width));
#    odashes = PyDict_GetItem(oborder, dictkey_dashes);
#    ostyle = PyDict_GetItem(oborder, dictkey_style);
#
#    // then delete any relevant entries
#    pdf_dict_del(ctx, annot_obj, PDF_NAME(BS));
#    pdf_dict_del(ctx, annot_obj, PDF_NAME(BE));
#    pdf_dict_del(ctx, annot_obj, PDF_NAME(Border));
#
#    Py_ssize_t i, n;
#    int d;
#    // populate new border array
#    if (nwidth < 0) nwidth = owidth;     // no new width: take current
#    if (nwidth < 0) nwidth = 0.0f;       // default if no width given
#    if (!ndashes) ndashes = odashes;     // no new dashes: take old
#    if (!nstyle)  nstyle  = ostyle;      // no new style: take old
#
#    if (ndashes && PySequence_Check(ndashes) && PySequence_Size(ndashes) > 0) {
#        n = PySequence_Size(ndashes);
#        pdf_obj *darr = pdf_new_array(ctx, doc, n);
#        for (i = 0; i < n; i++) {
#            d = (int) PyInt_AsLong(PySequence_ITEM(ndashes, i));
#            pdf_array_push_int(ctx, darr, (int64_t) d);
#        }
#        pdf_dict_putl_drop(ctx, annot_obj, darr, PDF_NAME(BS), PDF_NAME(D), NULL);
#        nstyle = PyUnicode_FromString("D");
#    }
#
#    pdf_dict_putl_drop(ctx, annot_obj, pdf_new_real(ctx, nwidth),
#                               PDF_NAME(BS), PDF_NAME(W), NULL);
#
#    pdf_obj *val = JM_get_border_style(ctx, nstyle);
#
#    pdf_dict_putl_drop(ctx, annot_obj, val,
#                               PDF_NAME(BS), PDF_NAME(S), NULL);
#
#    PyErr_Clear();
#    Py_RETURN_NONE;
#}
#
#PyObject *JM_annot_colors(fz_context *ctx, pdf_obj *annot_obj)
#{
#    PyObject *res = PyDict_New();
#    PyObject *bc = PyList_New(0);        // stroke colors
#    PyObject *fc = PyList_New(0);        // fill colors
#    int i;
#    float col;
#    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(C));
#    if (pdf_is_array(ctx, o)) {
#        int n = pdf_array_len(ctx, o);
#        for (i = 0; i < n; i++) {
#            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
#            LIST_APPEND_DROP(bc, Py_BuildValue("f", col));
#        }
#    }
#    DICT_SETITEM_DROP(res, dictkey_stroke, bc);
#
#    o = pdf_dict_gets(ctx, annot_obj, "IC");
#    if (pdf_is_array(ctx, o)) {
#        int n = pdf_array_len(ctx, o);
#        for (i = 0; i < n; i++) {
#            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
#            LIST_APPEND_DROP(fc, Py_BuildValue("f", col));
#        }
#    }
#    DICT_SETITEM_DROP(res, dictkey_fill, fc);
#
#    return res;
#}
#
##------------------------------------------------------------------------
## delete an annotation using mupdf functions, but first delete the /AP
## dict key in annot->obj.
##------------------------------------------------------------------------
#void JM_delete_annot(fz_context *ctx, pdf_page *page, pdf_annot *annot)
#{
#    if (!annot) return;
#    fz_try(ctx) {
#        // first get any existing popup for the annotation
#        pdf_obj *popup = pdf_dict_get(ctx, annot->obj, PDF_NAME(Popup));
#
#        // next delete the /Popup and /AP entries from annot dictionary
#        pdf_dict_del(ctx, annot->obj, PDF_NAME(AP));
#
#        pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
#        int i, n = pdf_array_len(ctx, annots);
#        for (i = n - 1; i >= 0; i--) {
#            pdf_obj *o = pdf_array_get(ctx, annots, i);
#            pdf_obj *p = pdf_dict_get(ctx, o, PDF_NAME(Parent));
#            if (!p) continue;
#            if (!pdf_objcmp(ctx, p, annot->obj)) {
#                pdf_array_delete(ctx, annots, i);
#            }
#        }
#        int type = pdf_annot_type(ctx, annot);
#        if (type != PDF_ANNOT_WIDGET) {
#            pdf_delete_annot(ctx, page, annot);
#        } else {
#            JM_delete_widget(ctx, page, annot);
#        }
#    }
#    fz_catch(ctx) {
#        fz_warn(ctx, "could not delete annotation");
#    }
#    return;
#}
#
##------------------------------------------------------------------------
## Return the first annotation whose /IRT key ("In Response To") points to
## annot. Used to remove the response chain of a given annotation.
##------------------------------------------------------------------------
#pdf_annot *JM_find_annot_irt(fz_context *ctx, pdf_annot *annot)
#{
#    pdf_annot *irt_annot = NULL;  // returning this
#    pdf_obj *o = NULL;
#    pdf_annot **annotptr;
#    int found = 0;
#    fz_try(ctx) {   // loop thru MuPDF's internal annots array
#        pdf_page *page = annot->page;
#        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
#            irt_annot = *annotptr;  // check if this is what we are looking for
#            o = pdf_dict_gets(ctx, irt_annot->obj, "IRT");
#            if (o) {
#                if (!pdf_objcmp(ctx, o, annot->obj)) {
#                    found = 1;
#                    break;
#                }
#            }
#        }
#    }
#    fz_catch(ctx) {;}
#    if (found) return irt_annot;
#    return NULL;
#}
#
##------------------------------------------------------------------------
## return the identifications of a page's annotations (list of /NM entries)
##------------------------------------------------------------------------
#PyObject *JM_get_annot_id_list(fz_context *ctx, pdf_page *page)
#{
#    PyObject *names = PyList_New(0);
#    pdf_obj *annot_obj = NULL;
#    pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
#    pdf_obj *name = NULL;
#    if (!annots) return names;
#    fz_try(ctx) {
#        int i, n = pdf_array_len(ctx, annots);
#        for (i = 0; i < n; i++) {
#            annot_obj = pdf_array_get(ctx, annots, i);
#            name = pdf_dict_gets(ctx, annot_obj, "NM");
#            if (name) {
#                LIST_APPEND_DROP(names, Py_BuildValue("s", pdf_to_text_string(ctx, name)));
#            }
#        }
#    }
#    fz_catch(ctx) {
#        return names;
#    }
#    return names;
#}
#
#
##------------------------------------------------------------------------
## return the xrefs and /NM ids of a page's annots, links and fields
##------------------------------------------------------------------------
#PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_page *page)
#{
#    PyObject *names = PyList_New(0);
#    pdf_obj *id, *annot_obj = NULL;
#    pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
#    if (!annots) return names;
#    fz_try(ctx) {
#        int i, n = pdf_array_len(ctx, annots);
#        for (i = 0; i < n; i++) {
#            annot_obj = pdf_array_get(ctx, annots, i);
#            int xref = pdf_to_num(ctx, annot_obj);
#            pdf_obj *subtype = pdf_dict_get(ctx, annot_obj, PDF_NAME(Subtype));
#            int type = PDF_ANNOT_UNKNOWN;
#            if (subtype) {
#                const char *name = pdf_to_name(ctx, subtype);
#                type = pdf_annot_type_from_string(ctx, name);
#            }
#            id = pdf_dict_gets(gctx, annot_obj, "NM");
#            LIST_APPEND_DROP(names, Py_BuildValue("iis", xref, type,pdf_to_text_string(gctx, id)));
#        }
#    }
#    fz_catch(ctx) {
#        return names;
#    }
#    return names;
def JM_get_annot_xref_list(page_or_page_obj):
    '''
    Wrapper for PyMuPDF/fitz/helper-annot.i:
        PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_obj *page_obj)

    Not PyMuPDF/fitz/fitz_wrap.c:
        PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_page *page)
    '''
    if 0 and isinstance(page_or_page_obj, mupdf.PdfObj):
        # Wrapper for PyMuPDF/fitz/helper-annot.i:
        #   PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_obj *page_obj)
        page_obj = page_or_page_obj
        names = []
        jlib.log('{page_obj=}')
        jlib.log('{mupdf.PDF_ENUM_NAME_Annots=}')
        jlib.log('calling page_obj.dict_get()')
        annots = page_obj.dict_get(mupdf.PDF_ENUM_NAME_Annots)
        jlib.log('{annots=}')
        if not annots:
            return names
        n = annots.array_len()
        jlib.log('{n=}')
        for i in range(n):
            annot_obj = mupdf.ppdf_array_get(annots, i)
            xref = mupdf.ppdf_to_num(annot_obj)
            jlib.log('{mupdf.PDF_ENUM_NAME_Subtype=}')
            subtype = mupdf.ppdf_dict_get(annot_obj, mupdf.PDF_ENUM_NAME_Subtype)
            type_ = mupdf.PDF_ANNOT_UNKNOWN
            if (subtype):
                name = mupdf.ppdf_to_name(subtype)
                type_ = mupdf.ppdf_annot_type_from_string(name)
            id_ = mupdf.ppdf_dict_gets(annot_obj, "NM")
            names.append( (xref, type_, mupdf.ppdf_to_text_string(id_)) )
        return names
    elif 0 and isinstance(page_or_page_obj, mupdf.PdfPage):
        # Not PyMuPDF/fitz/fitz_wrap.c:
        #   PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_page *page)
        page = page_or_page_obj
        names = []
        annots = page.obj().dict_get(mupdf.PDF_ENUM_NAME_Annots)
        if not annots.m_internal:
            return names
        n = annots.array_len()
        for i in range(n):
            annot_obj = annots.array_get(i)
            xref = annot_obj.to_num()
            subtype = annot_obj.dict_get(mupdf.PDF_ENUM_NAME_Subtype)
            type_ = mupdf.PDF_ANNOT_UNKNOWN
            if subtype.m_internal:
                name = subtype.to_name()
                type_ = name.annot_type_from_string()
            id_ = annot_obj.dict_gets("NM")
            names.append( (xref, type_, id_.to_text_string()))
        return names

    else:
        if isinstance(page_or_page_obj, mupdf.PdfPage):
            obj = page_or_page_obj.obj()
        elif isinstance(page_or_page_obj, mupdf.PdfObj):
            obj = page_or_page_obj
        else:
            assert 0
        names = []
        annots = obj.dict_get(mupdf.PDF_ENUM_NAME_Annots)
        if not annots.m_internal:
            return names
        n = annots.array_len()
        for i in range(n):
            annot_obj = annots.array_get(i)
            xref = annot_obj.to_num()
            subtype = annot_obj.dict_get(mupdf.PDF_ENUM_NAME_Subtype)
            type_ = mupdf.PDF_ANNOT_UNKNOWN
            if subtype.m_internal:
                name = subtype.to_name()
                type_ = mupdf.ppdf_annot_type_from_string(name)
            id_ = annot_obj.dict_gets("NM")
            names.append( (xref, type_, id_.to_text_string()))
        return names

#}
#
#
##------------------------------------------------------------------------
## Add a unique /NM key to an annotation or widget.
## Append a number to 'stem' such that the result is a unique name.
##------------------------------------------------------------------------
#static char JM_annot_id_stem[50] = "fitz";
#void JM_add_annot_id(fz_context *ctx, pdf_annot *annot, char *stem)
#{
#    fz_try(ctx) {
#        PyObject *names = NULL;
#        names = JM_get_annot_id_list(ctx, annot->page);
#        int i = 0;
#        PyObject *stem_id = NULL;
#        while (1) {
#            stem_id = PyUnicode_FromFormat("%s-%s%d", JM_annot_id_stem, stem, i);
#            if (!PySequence_Contains(names, stem_id)) break;
#            i += 1;
#            Py_DECREF(stem_id);
#        }
#        char *response = JM_StrAsChar(stem_id);
#        pdf_obj *name = pdf_new_string(ctx, (const char *) response, strlen(response));
#        pdf_dict_puts_drop(ctx, annot->obj, "NM", name);
#        Py_CLEAR(stem_id);
#        Py_CLEAR(names);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
##------------------------------------------------------------------------
## retrieve annot by name (/NM key)
##------------------------------------------------------------------------
#pdf_annot *JM_get_annot_by_name(fz_context *ctx, pdf_page *page, char *name)
#{
#    if (!name or strlen(name) == 0) {
#        return NULL;
#    }
#    pdf_annot **annotptr = NULL;
#    pdf_annot *annot = NULL;
#    int found = 0;
#    size_t len = 0;
#
#    fz_try(ctx) {   // loop thru MuPDF's internal annots and widget arrays
#        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
#            annot = *annotptr;
#            const char *response = pdf_to_string(ctx, pdf_dict_gets(ctx, annot->obj, "NM"), &len);
#            if (strcmp(name, response) == 0) {
#                found = 1;
#                break;
#            }
#        }
#        if (!found) {
#            fz_throw(ctx, FZ_ERROR_GENERIC, "'%s' is not an annot of this page", name);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return pdf_keep_annot(ctx, annot);
#}
#
##------------------------------------------------------------------------
## retrieve annot by its xref
##------------------------------------------------------------------------
#pdf_annot *JM_get_annot_by_xref(fz_context *ctx, pdf_page *page, int xref)
#{
#    pdf_annot **annotptr = NULL;
#    pdf_annot *annot = NULL;
#    int found = 0;
#    size_t len = 0;
#
#    fz_try(ctx) {   // loop thru MuPDF's internal annots array
#        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
#            annot = *annotptr;
#            if (xref == pdf_to_num(ctx, annot->obj)) {
#                found = 1;
#                break;
#            }
#        }
#        if (!found) {
#            fz_throw(ctx, FZ_ERROR_GENERIC, "xref %d is not an annot of this page", xref);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return pdf_keep_annot(ctx, annot);
#}
#
#
#
##-----------------------------------------------------------------------------
## Make a text page directly from an fz_page
##-----------------------------------------------------------------------------
#fz_stext_page *JM_new_stext_page_from_page(fz_context *ctx, fz_page *page, fz_rect rect, int flags)
#{
#    if (!page) return NULL;
#    fz_stext_page *tp = NULL;
#    fz_device *dev = NULL;
#    fz_var(dev);
#    fz_var(tp);
#    fz_stext_options options = { 0 };
#    options.flags = flags;
#    fz_try(ctx) {
#        tp = fz_new_stext_page(ctx, rect);
#        dev = fz_new_stext_device(ctx, tp, &options);
#        fz_run_page(ctx, page, dev, fz_identity, NULL);
#        fz_close_device(ctx, dev);
#    }
#    fz_always(ctx) {
#        fz_drop_device(ctx, dev);
#    }
#    fz_catch(ctx) {
#        fz_drop_stext_page(ctx, tp);
#        fz_rethrow(ctx);
#    }
#    return tp;
#}
#
#
##---------------------------------------------------------------------------
## APPEND non-ascii runes in unicode escape format to fz_buffer
##---------------------------------------------------------------------------
#void JM_append_rune(fz_context *ctx, fz_buffer *buff, int ch)
#{
#    if (ch >= 32 && ch <= 127 or ch == 10) {
#        fz_append_byte(ctx, buff, ch);
#    } else if (ch <= 0xffff) {  // 4 hex digits
#        fz_append_printf(ctx, buff, "\\u%04x", ch);
#    } else {  // 8 hex digits
#        fz_append_printf(ctx, buff, "\\U%08x", ch);
#    }
#}
#
## Switch for computing glyph of fontsize height
#static int small_glyph_heights = 0;
#
## re-compute char quad if ascender/descender values make no sense
#static fz_quad
#JM_char_quad(fz_context *ctx, fz_stext_line *line, fz_stext_char *ch)
#{
#    if (line->wmode) {  // never touch vertical write mode
#        return ch->quad;
#    }
#    float asc = fz_font_ascender(ctx, ch->font);
#    float dsc = fz_font_descender(ctx, ch->font);
#    if (asc - dsc >= 1 && small_glyph_heights == 0) {  // no problem
#        return ch->quad;
#    }
#    /* ------------------------------
#    Re-compute quad with adjusted ascender / descender values:
#    Move ch->origin to (0,0) and de-rotate quad, then adjust the corners,
#    re-rotate and move back to ch->origin location.
#    ------------------------------ */
#    float c, s, fsize = ch->size;
#    fz_matrix trm1, trm2, xlate1, xlate2;
#    fz_quad quad;
#    fz_rect bbox = fz_font_bbox(ctx, ch->font);
#    float fwidth = bbox.x1 - bbox.x0;
#    if (asc < 1e-3) {  // probably Tesseract glyphless font
#        dsc = -0.1f;
#    }
#
#    // Re-compute asc, dsc if there are problems.
#    // In that case, we also do not trust dsc and try correcting it.
#    if (asc - dsc < 1) {
#        if (bbox.y0 < dsc) {
#            dsc = bbox.y0;
#        }
#        asc = 1 + dsc;
#    }
#
#    c = line->dir.x;  // cosine
#    s = line->dir.y;  // sine
#    trm1 = fz_make_matrix(c, -s, s, c, 0, 0);  // derotate
#    trm2 = fz_make_matrix(c, s, -s, c, 0, 0);  // rotate
#    xlate1 = fz_make_matrix(1, 0, 0, 1, -ch->origin.x, -ch->origin.y);
#    xlate2 = fz_make_matrix(1, 0, 0, 1, ch->origin.x, ch->origin.y);
#
#    quad = fz_transform_quad(ch->quad, xlate1);  // move origin to (0,0)
#    quad = fz_transform_quad(quad, trm1);  // de-rotate corners
#
#    // adjust vertical coordinates
#    quad.ll.y = -fsize * dsc / (asc - dsc);
#    quad.ul.y = quad.ll.y - fsize;
#    quad.lr.y = quad.ll.y;
#    quad.ur.y = quad.ul.y;
#    // adjust horizontal coordinates
#    if ((quad.lr.x - quad.ll.x) < FLT_EPSILON) {
#        quad.lr.x = quad.ll.x + fwidth * fsize;
#        quad.ur.x = quad.lr.x;
#    }
#
#    quad = fz_transform_quad(quad, trm2);  // rotate back
#    quad = fz_transform_quad(quad, xlate2);  // translate back
#    return quad;
#}
#
#
## return rect of char quad
#static fz_rect
#JM_char_bbox(fz_context *ctx, fz_stext_line *line, fz_stext_char *ch)
#{
#    fz_rect r = fz_rect_from_quad(JM_char_quad(ctx, line, ch));
#    return r;
#}
#
#
##-------------------------------------------
## make a buffer from an stext_page's text
##-------------------------------------------
#fz_buffer *
#JM_new_buffer_from_stext_page(fz_context *ctx, fz_stext_page *page)
#{
#    fz_stext_block *block;
#    fz_stext_line *line;
#    fz_stext_char *ch;
#    fz_rect rect = page->mediabox;
#    fz_buffer *buf = NULL;
#
#    fz_try(ctx)
#    {
#        buf = fz_new_buffer(ctx, 256);
#        for (block = page->first_block; block; block = block->next) {
#            if (block->type == FZ_STEXT_BLOCK_TEXT) {
#                for (line = block->u.t.first_line; line; line = line->next) {
#                    for (ch = line->first_char; ch; ch = ch->next) {
#                        if (!fz_contains_rect(rect, JM_char_bbox(gctx, line, ch)) &&
#                            !fz_is_infinite_rect(rect)) {
#                            continue;
#                        }
#                        fz_append_rune(ctx, buf, ch->c);
#                    }
#                    fz_append_byte(ctx, buf, '\n');
#                }
#                fz_append_byte(ctx, buf, '\n');
#            }
#        }
#    }
#    fz_catch(ctx) {
#        fz_drop_buffer(ctx, buf);
#        fz_rethrow(ctx);
#    }
#    return buf;
#}
#
#
#static float hdist(fz_point *dir, fz_point *a, fz_point *b)
#{
#    float dx = b->x - a->x;
#    float dy = b->y - a->y;
#    return fz_abs(dx * dir->x + dy * dir->y);
#}
#
#
#static float vdist(fz_point *dir, fz_point *a, fz_point *b)
#{
#    float dx = b->x - a->x;
#    float dy = b->y - a->y;
#    return fz_abs(dx * dir->y + dy * dir->x);
#}
#
#
#struct highlight
#{
#    Py_ssize_t len;
#    PyObject *quads;
#    float hfuzz, vfuzz;
#};
#
#
#static void on_highlight_char(fz_context *ctx, void *arg, fz_stext_line *line, fz_stext_char *ch)
#{
#    struct highlight *hits = arg;
#    float vfuzz = ch->size * hits->vfuzz;
#    float hfuzz = ch->size * hits->hfuzz;
#    fz_quad ch_quad = JM_char_quad(ctx, line, ch);
#    if (hits->len > 0) {
#        PyObject *quad = PySequence_ITEM(hits->quads, hits->len - 1);
#        fz_quad end = JM_quad_from_py(quad);
#        Py_DECREF(quad);
#        if (hdist(&line->dir, &end.lr, &ch_quad.ll) < hfuzz
#            && vdist(&line->dir, &end.lr, &ch_quad.ll) < vfuzz
#            && hdist(&line->dir, &end.ur, &ch_quad.ul) < hfuzz
#            && vdist(&line->dir, &end.ur, &ch_quad.ul) < vfuzz)
#        {
#            end.ur = ch_quad.ur;
#            end.lr = ch_quad.lr;
#            quad = JM_py_from_quad(end);
#            PyList_SetItem(hits->quads, hits->len - 1, quad);
#            return;
#        }
#    }
#    LIST_APPEND_DROP(hits->quads, JM_py_from_quad(ch_quad));
#    hits->len++;
#}
#
#
#static inline int canon(int c)
#{
#	/* TODO: proper unicode case folding */
#	/* TODO: character equivalence (a matches , etc) */
#	if (c == 0xA0 or c == 0x2028 or c == 0x2029)
#		return ' ';
#	if (c == '\r' or c == '\n' or c == '\t')
#		return ' ';
#	if (c >= 'A' && c <= 'Z')
#		return c - 'A' + 'a';
#	return c;
#}
#
#
#static inline int chartocanon(int *c, const char *s)
#{
#	int n = fz_chartorune(c, s);
#	*c = canon(*c);
#	return n;
#}
#
#
#static const char *match_string(const char *h, const char *n)
#{
#	int hc, nc;
#	const char *e = h;
#	h += chartocanon(&hc, h);
#	n += chartocanon(&nc, n);
#	while (hc == nc)
#	{
#		e = h;
#		if (hc == ' ')
#			do
#				h += chartocanon(&hc, h);
#			while (hc == ' ');
#		else
#			h += chartocanon(&hc, h);
#		if (nc == ' ')
#			do
#				n += chartocanon(&nc, n);
#			while (nc == ' ');
#		else
#			n += chartocanon(&nc, n);
#	}
#	return nc == 0 ? e : NULL;
#}
#
#
#static const char *find_string(const char *s, const char *needle, const char **endp)
#{
#    const char *end;
#    while (*s)
#    {
#        end = match_string(s, needle);
#        if (end)
#            return *endp = end, s;
#        ++s;
#    }
#    return *endp = NULL, NULL;
#}
#
#
#PyObject *
#JM_search_stext_page(fz_context *ctx, fz_stext_page *page, const char *needle)
#{
#    struct highlight hits;
#    fz_stext_block *block;
#    fz_stext_line *line;
#    fz_stext_char *ch;
#    fz_buffer *buffer = NULL;
#    const char *haystack, *begin, *end;
#    int c, inside;
#
#    if (strlen(needle) == 0) Py_RETURN_NONE;
#    PyObject *quads = PyList_New(0);
#    hits.len = 0;
#    hits.quads = quads;
#    hits.hfuzz = 0.2f; /* merge kerns but not large gaps */
#    hits.vfuzz = 0.1f;
#
#    fz_try(ctx) {
#        buffer = JM_new_buffer_from_stext_page(ctx, page);
#        haystack = fz_string_from_buffer(ctx, buffer);
#        begin = find_string(haystack, needle, &end);
#        if (!begin) goto no_more_matches;
#
#        inside = 0;
#        for (block = page->first_block; block; block = block->next) {
#            if (block->type != FZ_STEXT_BLOCK_TEXT) {
#                continue;
#            }
#            for (line = block->u.t.first_line; line; line = line->next) {
#                for (ch = line->first_char; ch; ch = ch->next) {
#try_new_match:
#                    if (!inside) {
#                        if (haystack >= begin) inside = 1;
#                    }
#                    if (inside) {
#                        if (haystack < end) {
#                            on_highlight_char(ctx, &hits, line, ch);
#                        } else {
#                            inside = 0;
#                            begin = find_string(haystack, needle, &end);
#                            if (!begin) goto no_more_matches;
#                            else goto try_new_match;
#                        }
#                    }
#                    haystack += fz_chartorune(&c, haystack);
#                }
#                assert(*haystack == '\n');
#                ++haystack;
#            }
#            assert(*haystack == '\n');
#            ++haystack;
#        }
#no_more_matches:;
#    }
#    fz_always(ctx)
#        fz_drop_buffer(ctx, buffer);
#    fz_catch(ctx)
#        fz_rethrow(ctx);
#
#    return quads;
#}
#
#
##-----------------------------------------------------------------------------
## Plain text output. An identical copy of fz_print_stext_page_as_text,
## but lines within a block are concatenated by space instead a new-line
## character (which else leads to 2 new-lines).
##-----------------------------------------------------------------------------
#void
#JM_print_stext_page_as_text(fz_context *ctx, fz_output *out, fz_stext_page *page)
#{
#    fz_stext_block *block;
#    fz_stext_line *line;
#    fz_stext_char *ch;
#    fz_rect rect = page->mediabox;
#    int last_char = 0;
#
#    for (block = page->first_block; block; block = block->next) {
#        if (block->type == FZ_STEXT_BLOCK_TEXT) {
#            for (line = block->u.t.first_line; line; line = line->next) {
#                last_char = 0;
#                for (ch = line->first_char; ch; ch = ch->next) {
#                    if (fz_is_infinite_rect(rect) ||
#                        fz_contains_rect(rect, JM_char_bbox(gctx, line, ch))) {
#                        last_char = ch->c;
#                        fz_write_rune(ctx, out, ch->c);
#                    }
#                }
#                if (last_char != 10 && last_char) fz_write_string(ctx, out, "\n");
#            }
#        }
#    }
#}
#
##-----------------------------------------------------------------------------
## Functions for wordlist output
##-----------------------------------------------------------------------------
#int JM_append_word(fz_context *ctx, PyObject *lines, fz_buffer *buff, fz_rect *wbbox,
#                   int block_n, int line_n, int word_n)
#{
#    PyObject *s = JM_EscapeStrFromBuffer(ctx, buff);
#    PyObject *litem = Py_BuildValue("ffffOiii",
#                                    wbbox->x0,
#                                    wbbox->y0,
#                                    wbbox->x1,
#                                    wbbox->y1,
#                                    s,
#                                    block_n, line_n, word_n);
#    LIST_APPEND_DROP(lines, litem);
#    Py_DECREF(s);
#    wbbox->x0 = wbbox->y0 = wbbox->x1 = wbbox->y1 = 0;
#    return word_n + 1;                 // word counter
#}
#
##-----------------------------------------------------------------------------
## Functions for dictionary output
##-----------------------------------------------------------------------------
#
#static int detect_super_script(fz_stext_line *line, fz_stext_char *ch)
#{
#    if (line->wmode == 0 && line->dir.x == 1 && line->dir.y == 0)
#        return ch->origin.y < line->first_char->origin.y - ch->size * 0.1f;
#    return 0;
#}
#
#static int JM_char_font_flags(fz_context *ctx, fz_font *font, fz_stext_line *line, fz_stext_char *ch)
#{
#    int flags = detect_super_script(line, ch);
#    flags += fz_font_is_italic(ctx, font) * TEXT_FONT_ITALIC;
#    flags += fz_font_is_serif(ctx, font) * TEXT_FONT_SERIFED;
#    flags += fz_font_is_monospaced(ctx, font) * TEXT_FONT_MONOSPACED;
#    flags += fz_font_is_bold(ctx, font) * TEXT_FONT_BOLD;
#    return flags;
#}
#
#static const char *
#JM_font_name(fz_context *ctx, fz_font *font)
#{
#    const char *name = fz_font_name(ctx, font);
#    const char *s = strchr(name, '+');
#    return s ? s + 1 : name;
#}
#
#
#static fz_rect
#JM_make_spanlist(fz_context *ctx, PyObject *line_dict,
#                 fz_stext_line *line, int raw, fz_buffer *buff,
#                 fz_rect tp_rect)
#{
#    PyObject *span = NULL, *char_list = NULL, *char_dict;
#    PyObject *span_list = PyList_New(0);
#    fz_clear_buffer(ctx, buff);
#    fz_stext_char *ch;
#    fz_rect span_rect;
#    fz_rect line_rect = fz_empty_rect;
#    fz_point span_origin;
#    typedef struct style_s
#    {float size; int flags; const char *font; int color; float asc; float desc;} char_style;
#
#    char_style old_style = { -1, -1, "", -1, 0, 0 }, style;
#
#    for (ch = line->first_char; ch; ch = ch->next) {
##start-trace
#        fz_rect r = JM_char_bbox(gctx, line, ch);
#        if (!fz_contains_rect(tp_rect, r) &&
#            !fz_is_infinite_rect(tp_rect)) {
#            continue;
#        }
#
#        int flags = JM_char_font_flags(ctx, ch->font, line, ch);
#        fz_point origin = ch->origin;
#        style.size = ch->size;
#        style.flags = flags;
#        style.font = JM_font_name(ctx, ch->font);
#        style.asc = fz_font_ascender(ctx, ch->font);
#        style.desc = fz_font_descender(ctx, ch->font);
#        style.color = ch->color;
#
#        if (style.size != old_style.size ||
#            style.flags != old_style.flags ||
#            style.color != old_style.color ||
#            strcmp(style.font, old_style.font) != 0) {
#
#            // style changed -> make new span
#
#            if (old_style.size >= 0) {
#                // not first one, output previous
#                if (raw) {
#                    // put character list in the span
#                    DICT_SETITEM_DROP(span, dictkey_chars, char_list);
#                    char_list = NULL;
#                } else {
#                    // put text string in the span
#                    DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
#                    fz_clear_buffer(ctx, buff);
#                }
#
#                DICT_SETITEM_DROP(span, dictkey_origin,
#                    JM_py_from_point(span_origin));
#                DICT_SETITEM_DROP(span, dictkey_bbox,
#                    JM_py_from_rect(span_rect));
#                line_rect = fz_union_rect(line_rect, span_rect);
#                if (!fz_is_empty_rect(span_rect)) {
#                    LIST_APPEND_DROP(span_list, span);
#                } else {
#                    Py_DECREF(span);
#                }
#                span = NULL;
#            }
#
#            span = PyDict_New();
#            float asc = style.asc, desc = style.desc;
#            if (style.asc < 1e-3) {
#                asc = 0.9f;
#                desc = -0.1f;
#            }
#
#            DICT_SETITEM_DROP(span, dictkey_size, Py_BuildValue("f", style.size));
#            DICT_SETITEM_DROP(span, dictkey_flags, Py_BuildValue("i", style.flags));
#            DICT_SETITEM_DROP(span, dictkey_font, JM_EscapeStrFromStr(style.font));
#            DICT_SETITEM_DROP(span, dictkey_color, Py_BuildValue("i", style.color));
#            DICT_SETITEMSTR_DROP(span, "ascender", Py_BuildValue("f", asc));
#            DICT_SETITEMSTR_DROP(span, "descender", Py_BuildValue("f", desc));
#
#            old_style = style;
#            span_rect = r;
#            span_origin = origin;
#
#        }
#        span_rect = fz_union_rect(span_rect, r);
#        if (origin.y > span_origin.y) {
#            span_origin.y = origin.y;
#        }
#
#        if (raw) {  // make and append a char dict
#            char_dict = PyDict_New();
#
#            DICT_SETITEM_DROP(char_dict, dictkey_origin,
#                          JM_py_from_point(ch->origin));
#
#            DICT_SETITEM_DROP(char_dict, dictkey_bbox,
#                          JM_py_from_rect(r));
#
#            DICT_SETITEM_DROP(char_dict, dictkey_c,
#                          Py_BuildValue("C", ch->c));
#
#            if (!char_list) {
#                char_list = PyList_New(0);
#            }
#            LIST_APPEND_DROP(char_list, char_dict);
#        } else {  // add character byte to buffer
#            JM_append_rune(ctx, buff, ch->c);
#        }
#    }
#    // all characters processed, now flush remaining span
#    if (span) {
#        if (raw) {
#            DICT_SETITEM_DROP(span, dictkey_chars, char_list);
#            char_list = NULL;
#        } else {
#            DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
#            fz_clear_buffer(ctx, buff);
#        }
#        DICT_SETITEM_DROP(span, dictkey_origin, JM_py_from_point(span_origin));
#        DICT_SETITEM_DROP(span, dictkey_bbox, JM_py_from_rect(span_rect));
#
#        if (!fz_is_empty_rect(span_rect)) {
#            LIST_APPEND_DROP(span_list, span);
#            line_rect = fz_union_rect(line_rect, span_rect);
#        } else {
#            Py_DECREF(span);
#        }
#        span = NULL;
#    }
#    if (!fz_is_empty_rect(line_rect)) {
#        DICT_SETITEM_DROP(line_dict, dictkey_spans, span_list);
#    } else {
#        DICT_SETITEM_DROP(line_dict, dictkey_spans, span_list);
#    }
##stop-trace
#    return line_rect;
#}
#
#static void JM_make_image_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict)
#{
#    fz_image *image = block->u.i.image;
#    fz_buffer *buf = NULL, *freebuf = NULL;
#    fz_compressed_buffer *buffer = fz_compressed_image_buffer(ctx, image);
#    fz_var(buf);
#    fz_var(freebuf);
#    int n = fz_colorspace_n(ctx, image->colorspace);
#    int w = image->w;
#    int h = image->h;
#    const char *ext = NULL;
#    int type = FZ_IMAGE_UNKNOWN;
#    if (buffer)
#        type = buffer->params.type;
#    if (type < FZ_IMAGE_BMP or type == FZ_IMAGE_JBIG2)
#        type = FZ_IMAGE_UNKNOWN;
#    PyObject *bytes = NULL;
#    fz_var(bytes);
#    fz_try(ctx) {
#        if (buffer && type != FZ_IMAGE_UNKNOWN) {
#            buf = buffer->buffer;
#            ext = JM_image_extension(type);
#        } else {
#            buf = freebuf = fz_new_buffer_from_image_as_png(ctx, image, fz_default_color_params);
#            ext = "png";
#        }
#        bytes = JM_BinFromBuffer(ctx, buf);
#    }
#    fz_always(ctx) {
#        if (!bytes)
#            bytes = JM_BinFromChar("");
#        DICT_SETITEM_DROP(block_dict, dictkey_width,
#                          Py_BuildValue("i", w));
#        DICT_SETITEM_DROP(block_dict, dictkey_height,
#                          Py_BuildValue("i", h));
#        DICT_SETITEM_DROP(block_dict, dictkey_ext,
#                          Py_BuildValue("s", ext));
#        DICT_SETITEM_DROP(block_dict, dictkey_colorspace,
#                          Py_BuildValue("i", n));
#        DICT_SETITEM_DROP(block_dict, dictkey_xres,
#                          Py_BuildValue("i", image->xres));
#        DICT_SETITEM_DROP(block_dict, dictkey_yres,
#                          Py_BuildValue("i", image->xres));
#        DICT_SETITEM_DROP(block_dict, dictkey_bpc,
#                          Py_BuildValue("i", (int) image->bpc));
#        DICT_SETITEM_DROP(block_dict, dictkey_image, bytes);
#
#        fz_drop_buffer(ctx, freebuf);
#    }
#    fz_catch(ctx) {;}
#    return;
#}
#
#static void JM_make_text_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict, int raw, #fz_buffer *buff, fz_rect tp_rect)
#{
#    fz_stext_line *line;
#    PyObject *line_list = PyList_New(0), *line_dict;
#    fz_rect block_rect = fz_empty_rect;
#    for (line = block->u.t.first_line; line; line = line->next) {
#        if (fz_is_empty_rect(fz_intersect_rect(tp_rect, line->bbox)) &&
#            !fz_is_infinite_rect(tp_rect)) {
#            continue;
#        }
#        line_dict = PyDict_New();
#        fz_rect line_rect = JM_make_spanlist(ctx, line_dict, line, raw, buff, tp_rect);
#        block_rect = fz_union_rect(block_rect, line_rect);
#        DICT_SETITEM_DROP(line_dict, dictkey_wmode,
#                    Py_BuildValue("i", line->wmode));
#        DICT_SETITEM_DROP(line_dict, dictkey_dir, JM_py_from_point(line->dir));
#        DICT_SETITEM_DROP(line_dict, dictkey_bbox,
#                    JM_py_from_rect(line_rect));
#        LIST_APPEND_DROP(line_list, line_dict);
#    }
#    DICT_SETITEM_DROP(block_dict, dictkey_bbox, JM_py_from_rect(block_rect));
#    DICT_SETITEM_DROP(block_dict, dictkey_lines, line_list);
#    return;
#}
#
#void JM_make_textpage_dict(fz_context *ctx, fz_stext_page *tp, PyObject *page_dict, int raw)
#{
#    fz_stext_block *block;
#    fz_buffer *text_buffer = fz_new_buffer(ctx, 128);
#    PyObject *block_dict, *block_list = PyList_New(0);
#    fz_rect tp_rect = tp->mediabox;
#    int block_n = -1;
#    for (block = tp->first_block; block; block = block->next) {
#        block_n++;
#        if (!fz_contains_rect(tp_rect, block->bbox) &&
#            !fz_is_infinite_rect(tp_rect) &&
#            block->type == FZ_STEXT_BLOCK_IMAGE) {
#            continue;
#        }
#        if (!fz_is_infinite_rect(tp_rect) &&
#            fz_is_empty_rect(fz_intersect_rect(tp_rect, block->bbox))) {
#            continue;
#        }
#
#        block_dict = PyDict_New();
#        DICT_SETITEM_DROP(block_dict, dictkey_number, Py_BuildValue("i", block_n));
#        DICT_SETITEM_DROP(block_dict, dictkey_type, Py_BuildValue("i", block->type));
#        if (block->type == FZ_STEXT_BLOCK_IMAGE) {
#            DICT_SETITEM_DROP(block_dict, dictkey_bbox, JM_py_from_rect(block->bbox));
#            JM_make_image_block(ctx, block, block_dict);
#        } else {
#            JM_make_text_block(ctx, block, block_dict, raw, text_buffer, tp_rect);
#        }
#
#        LIST_APPEND_DROP(block_list, block_dict);
#    }
#    DICT_SETITEM_DROP(page_dict, dictkey_blocks, block_list);
#    fz_drop_buffer(ctx, text_buffer);
#}
#
#
#fz_buffer *JM_object_to_buffer(fz_context *ctx, pdf_obj *what, int compress, int ascii)
#{
#    fz_buffer *res=NULL;
#    fz_output *out=NULL;
#    fz_try(ctx) {
#        res = fz_new_buffer(ctx, 1024);
#        out = fz_new_output_with_buffer(ctx, res);
#        pdf_print_obj(ctx, out, what, compress, ascii);
#    }
#    fz_always(ctx) {
#        fz_drop_output(ctx, out);
#    }
#    fz_catch(ctx) {
#        return NULL;
#    }
#    fz_terminate_buffer(gctx, res);
#    return res;
#}
#
##-----------------------------------------------------------------------------
## Merge the /Resources object created by a text pdf device into the page.
## The device may have created multiple /ExtGState/Alp? and /Font/F? objects.
## These need to be renamed (renumbered) to not overwrite existing page
## objects from previous executions.
## Returns the next available numbers n, m for objects /Alp<n>, /F<m>.
##-----------------------------------------------------------------------------
#PyObject *JM_merge_resources(fz_context *ctx, pdf_page *page, pdf_obj *temp_res)
#{
#    // page objects /Resources, /Resources/ExtGState, /Resources/Font
#    pdf_obj *resources = pdf_dict_get(ctx, page->obj, PDF_NAME(Resources));
#    pdf_obj *main_extg = pdf_dict_get(ctx, resources, PDF_NAME(ExtGState));
#    pdf_obj *main_fonts = pdf_dict_get(ctx, resources, PDF_NAME(Font));
#
#    // text pdf device objects /ExtGState, /Font
#    pdf_obj *temp_extg = pdf_dict_get(ctx, temp_res, PDF_NAME(ExtGState));
#    pdf_obj *temp_fonts = pdf_dict_get(ctx, temp_res, PDF_NAME(Font));
#
#
#    int max_alp = -1, max_fonts = -1, i, n;
#    char text[20];
#
#    // Handle /Alp objects
#    if (pdf_is_dict(ctx, temp_extg))  // any created at all?
#    {
#        n = pdf_dict_len(ctx, temp_extg);
#        if (pdf_is_dict(ctx, main_extg)) {  // does page have /ExtGState yet?
#            for (i = 0; i < pdf_dict_len(ctx, main_extg); i++) {
#                // get highest number of objects named /Alpxxx
#                char *alp = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_extg, i));
#                if (strncmp(alp, "Alp", 3) != 0) continue;
#                int j = fz_atoi(alp + 3);
#                if (j > max_alp) max_alp = j;
#            }
#        }
#        else  // create a /ExtGState for the page
#            main_extg = pdf_dict_put_dict(ctx, resources, PDF_NAME(ExtGState), n);
#
#        max_alp += 1;
#        for (i = 0; i < n; i++)  // copy over renumbered /Alp objects
#        {
#            char *alp = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, temp_extg, i));
#            int j = fz_atoi(alp + 3) + max_alp;
#            fz_snprintf(text, sizeof(text), "Alp%d", j);  // new name
#            pdf_obj *val = pdf_dict_get_val(ctx, temp_extg, i);
#            pdf_dict_puts(ctx, main_extg, text, val);
#        }
#    }
#
#
#    if (pdf_is_dict(ctx, main_fonts)) { // has page any fonts yet?
#        for (i = 0; i < pdf_dict_len(ctx, main_fonts); i++) { // get max font number
#            char *font = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_fonts, i));
#            if (strncmp(font, "F", 1) != 0) continue;
#            int j = fz_atoi(font + 1);
#            if (j > max_fonts) max_fonts = j;
#        }
#    }
#    else  // create a Resources/Font for the page
#        main_fonts = pdf_dict_put_dict(ctx, resources, PDF_NAME(Font), 2);
#
#    max_fonts += 1;
#    for (i = 0; i < pdf_dict_len(ctx, temp_fonts); i++) { // copy renumbered fonts
#        char *font = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, temp_fonts, i));
#        int j = fz_atoi(font + 1) + max_fonts;
#        fz_snprintf(text, sizeof(text), "F%d", j);
#        pdf_obj *val = pdf_dict_get_val(ctx, temp_fonts, i);
#        pdf_dict_puts(ctx, main_fonts, text, val);
#    }
#    return Py_BuildValue("ii", max_alp, max_fonts); // next available numbers
#}
#
#
##-----------------------------------------------------------------------------
## version of fz_show_string, which also covers UCDN script
##-----------------------------------------------------------------------------
#fz_matrix JM_show_string(fz_context *ctx, fz_text *text, fz_font *user_font, fz_matrix trm, const char #*s, int wmode, int bidi_level, fz_bidi_direction markup_dir, fz_text_language language, int script)
#{
#    fz_font *font;
#    int gid, ucs;
#    float adv;
#
#    while (*s) {
#        s += fz_chartorune(&ucs, s);
#        gid = fz_encode_character_with_fallback(ctx, user_font, ucs, script, language, &font);
#        fz_show_glyph(ctx, text, font, trm, gid, ucs, wmode, bidi_level, markup_dir, language);
#        adv = fz_advance_glyph(ctx, font, gid, wmode);
#        if (wmode == 0)
#            trm = fz_pre_translate(trm, adv, 0);
#        else
#            trm = fz_pre_translate(trm, 0, -adv);
#    }
#    return trm;
#}
#
#
##-----------------------------------------------------------------------------
## return a fz_font from a number of parameters
##-----------------------------------------------------------------------------
#fz_font *JM_get_font(fz_context *ctx,
#    char *fontname,
#    char *fontfile,
#    PyObject *fontbuffer,
#    int script,
#    int lang,
#    int ordering,
#    int is_bold,
#    int is_italic,
#    int is_serif)
#{
#    const unsigned char *data = NULL;
#    int size, index=0;
#    fz_buffer *res = NULL;
#    fz_font *font = NULL;
#    fz_try(ctx) {
#        if (fontfile) goto have_file;
#        if (EXISTS(fontbuffer)) goto have_buffer;
#        if (ordering > -1) goto have_cjk;
#        if (fontname) goto have_base14;
#        goto have_noto;
#
#        // Base-14 font
#        have_base14:;
#        data = fz_lookup_base14_font(ctx, fontname, &size);
#        if (data) font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
#        if(font) goto fertig;
#
#        data = fz_lookup_builtin_font(gctx, fontname, is_bold, is_italic, &size);
#        if (data) font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
#        goto fertig;
#
#        // CJK font
#        have_cjk:;
#        data = fz_lookup_cjk_font(ctx, ordering, &size, &index);
#        if (data) font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
#        goto fertig;
#
#        // fontfile
#        have_file:;
#        font = fz_new_font_from_file(ctx, NULL, fontfile, index, 0);
#        goto fertig;
#
#        // fontbuffer
#        have_buffer:;
#        res = JM_BufferFromBytes(ctx, fontbuffer);
#        font = fz_new_font_from_buffer(ctx, NULL, res, index, 0);
#        goto fertig;
#
#        // Check for NOTO font
#        have_noto:;
#        data = fz_lookup_noto_font(ctx, script, lang, &size, &index);
#        if (data) font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
#        if (font) goto fertig;
#        font = fz_load_fallback_font(ctx, script, lang, is_serif, is_bold, is_italic);
#        goto fertig;
#
#        fertig:;
#        if (!font) THROWMSG(ctx, "could not create font");
#    }
#    fz_always(ctx) {
#        fz_drop_buffer(ctx, res);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return font;
#}
#
#
#
##define SETATTR(a, v) PyObject_SetAttrString(Widget, a, v)
##define GETATTR(a) PyObject_GetAttrString(Widget, a)
##define CALLATTR(m, p) PyObject_CallMethod(Widget, m, p)
#
#static void
#SETATTR_DROP(PyObject *mod, const char *attr, PyObject *value)
#{
#    if (!value)
#        PyObject_DelAttrString(mod, attr);
#    else
#    {
#        PyObject_SetAttrString(mod, attr, value);
#        Py_DECREF(value);
#    }
#}
#
##-----------------------------------------------------------------------------
## Functions dealing with PDF form fields (widgets)
##-----------------------------------------------------------------------------
#enum
#{
#	SigFlag_SignaturesExist = 1,
#	SigFlag_AppendOnly = 2
#};
#
#
## make new PDF action object from JavaScript source
## Parameters are a PDF document and a Python string.
## Returns a PDF action object.
##-----------------------------------------------------------------------------
#pdf_obj *
#JM_new_javascript(fz_context *ctx, pdf_document *pdf, PyObject *value)
#{
#    fz_buffer *res = NULL;
#    if (!PyObject_IsTrue(value))  // no argument given
#        return NULL;
#
#    char *data = JM_StrAsChar(value);
#    if (!data)  // not convertible to char*
#        return NULL;
#
#    res = fz_new_buffer_from_copied_data(ctx, data, strlen(data));
#    pdf_obj *source = pdf_add_stream(ctx, pdf, res, NULL, 0);
#    pdf_obj *newaction = pdf_add_new_dict(ctx, pdf, 4);
#    pdf_dict_put(ctx, newaction, PDF_NAME(S), pdf_new_name(ctx, "JavaScript"));
#    pdf_dict_put(ctx, newaction, PDF_NAME(JS), source);
#    fz_drop_buffer(ctx, res);
#    return pdf_keep_obj(ctx, newaction);
#}
#
#
## JavaScript extractor
## Returns either the script source or None. Parameter is a PDF action
## dictionary, which must have keys /S and /JS. The value of /S must be
## '/JavaScript'. The value of /JS is returned.
##-----------------------------------------------------------------------------
#PyObject *
#JM_get_script(fz_context *ctx, pdf_obj *key)
#{
#    pdf_obj *js = NULL;
#    fz_buffer *res = NULL;
#    PyObject *script = NULL;
#    if (!key) Py_RETURN_NONE;
#
#    if (!strcmp(pdf_to_name(ctx,
#                pdf_dict_get(ctx, key, PDF_NAME(S))), "JavaScript")) {
#        js = pdf_dict_get(ctx, key, PDF_NAME(JS));
#    }
#    if (!js) Py_RETURN_NONE;
#
#    if (pdf_is_string(ctx, js)) {
#        script = JM_UnicodeFromStr(pdf_to_text_string(ctx, js));
#    } else if (pdf_is_stream(ctx, js)) {
#        res = pdf_load_stream(ctx, js);
#        script = JM_EscapeStrFromBuffer(ctx, res);
#        fz_drop_buffer(ctx, res);
#    } else {
#        Py_RETURN_NONE;
#    }
#    if (PyObject_IsTrue(script)) { // do not return an empty script
#        return script;
#    }
#    Py_CLEAR(script);
#    Py_RETURN_NONE;
#}
#
#
## Create a JavaScript PDF action.
## Usable for all object types which support PDF actions, even if the
## argument name suggests annotations. Up to 2 key values can be specified, so
## JavaScript actions can be stored for '/A' and '/AA/?' keys.
##-----------------------------------------------------------------------------
#void JM_put_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2, PyObject *value)
#{
#    PyObject *script = NULL;
#    pdf_obj *key1_obj = pdf_dict_get(ctx, annot_obj, key1);
#    pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);  // owning PDF
#
#    // if no new script given, just delete corresponding key
#    if (!value or !PyObject_IsTrue(value)) {
#        if (!key2) {
#            pdf_dict_del(ctx, annot_obj, key1);
#        } else if (key1_obj) {
#            pdf_dict_del(ctx, key1_obj, key2);
#        }
#        return;
#    }
#
#    // read any existing script as a PyUnicode string
#    if (!key2 or !key1_obj) {
#        script = JM_get_script(ctx, key1_obj);
#    } else {
#        script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
#    }
#
#    // replace old script, if different from new one
#    if (!PyObject_RichCompareBool(value, script, Py_EQ)) {
#        pdf_obj *newaction = JM_new_javascript(ctx, pdf, value);
#        if (!key2) {
#            pdf_dict_put_drop(ctx, annot_obj, key1, newaction);
#        } else {
#            pdf_dict_putl_drop(ctx, annot_obj, newaction, key1, key2, NULL);
#        }
#    }
#    Py_XDECREF(script);
#    return;
#}
#
#/*
## Execute a JavaScript action for annot or field.
##-----------------------------------------------------------------------------
#PyObject *
#JM_exec_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2)
#{
#    PyObject *script = NULL;
#    char *code = NULL;
#    fz_try(ctx) {
#        pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);
#        char buf[100];
#        if (!key2) {
#            script = JM_get_script(ctx, key1_obj);
#        } else {
#            script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
#        }
#        code = JM_StrAsChar(script);
#        fz_snprintf(buf, sizeof buf, "%d/A", pdf_to_num(ctx, annot_obj));
#        pdf_js_execute(pdf->js, buf, code);
#    }
#    fz_always(ctx) {
#        Py_XDECREF(string);
#    }
#    fz_catch(ctx) {
#        Py_RETURN_FALSE;
#    }
#    Py_RETURN_TRUE;
#}
#*/
#
## String from widget type
##-----------------------------------------------------------------------------
#char *JM_field_type_text(int wtype)
#{
#    switch(wtype) {
#        case(PDF_WIDGET_TYPE_BUTTON):
#            return "Button";
#        case(PDF_WIDGET_TYPE_CHECKBOX):
#            return "CheckBox";
#        case(PDF_WIDGET_TYPE_RADIOBUTTON):
#            return "RadioButton";
#        case(PDF_WIDGET_TYPE_TEXT):
#            return "Text";
#        case(PDF_WIDGET_TYPE_LISTBOX):
#            return "ListBox";
#        case(PDF_WIDGET_TYPE_COMBOBOX):
#            return "ComboBox";
#        case(PDF_WIDGET_TYPE_SIGNATURE):
#            return "Signature";
#        default:
#            return "unknown";
#    }
#}
#
## Set the field type
##-----------------------------------------------------------------------------
#void JM_set_field_type(fz_context *ctx, pdf_document *doc, pdf_obj *obj, int type)
#{
#	int setbits = 0;
#	int clearbits = 0;
#	pdf_obj *typename = NULL;
#
#	switch(type) {
#	case PDF_WIDGET_TYPE_BUTTON:
#		typename = PDF_NAME(Btn);
#		setbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
#		break;
#	case PDF_WIDGET_TYPE_CHECKBOX:
#		typename = PDF_NAME(Btn);
#		clearbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
#		setbits = PDF_BTN_FIELD_IS_RADIO;
#		break;
#	case PDF_WIDGET_TYPE_RADIOBUTTON:
#		typename = PDF_NAME(Btn);
#		clearbits = (PDF_BTN_FIELD_IS_PUSHBUTTON|PDF_BTN_FIELD_IS_RADIO);
#		break;
#	case PDF_WIDGET_TYPE_TEXT:
#		typename = PDF_NAME(Tx);
#		break;
#	case PDF_WIDGET_TYPE_LISTBOX:
#		typename = PDF_NAME(Ch);
#		clearbits = PDF_CH_FIELD_IS_COMBO;
#		break;
#	case PDF_WIDGET_TYPE_COMBOBOX:
#		typename = PDF_NAME(Ch);
#		setbits = PDF_CH_FIELD_IS_COMBO;
#		break;
#	case PDF_WIDGET_TYPE_SIGNATURE:
#		typename = PDF_NAME(Sig);
#		break;
#	}
#
#	if (typename)
#		pdf_dict_put_drop(ctx, obj, PDF_NAME(FT), typename);
#
#	if (setbits != 0 or clearbits != 0) {
#		int bits = pdf_dict_get_int(ctx, obj, PDF_NAME(Ff));
#		bits &= ~clearbits;
#		bits |= setbits;
#		pdf_dict_put_int(ctx, obj, PDF_NAME(Ff), bits);
#	}
#}
#
## Copied from MuPDF v1.14
## Create widget
##-----------------------------------------------------------------------------
#pdf_annot *JM_create_widget(fz_context *ctx, pdf_document *doc, pdf_page *page, int type, char #*fieldname)
#{
#	pdf_obj *form = NULL;
#	int old_sigflags = pdf_to_int(ctx, pdf_dict_getp(ctx, pdf_trailer(ctx, doc), #"Root/AcroForm/SigFlags"));
#	pdf_annot *annot = pdf_create_annot_raw(ctx, page, PDF_ANNOT_WIDGET);
#
#	fz_try(ctx) {
#		JM_set_field_type(ctx, doc, annot->obj, type);
#		pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(T), fieldname);
#
#		if (type == PDF_WIDGET_TYPE_SIGNATURE) {
#			int sigflags = (old_sigflags | (SigFlag_SignaturesExist|SigFlag_AppendOnly));
#			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, sigflags), PDF_NAME(Root), #PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);
#		}
#
#		/*
#		pdf_create_annot will have linked the new widget into the page's
#		annot array. We also need it linked into the document's form
#		*/
#		form = pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/Fields");
#		if (!form) {
#			form = pdf_new_array(ctx, doc, 1);
#			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc),
#                               form,
#                               PDF_NAME(Root),
#                               PDF_NAME(AcroForm),
#                               PDF_NAME(Fields),
#                               NULL);
#		}
#
#		pdf_array_push(ctx, form, annot->obj); // Cleanup relies on this statement being last
#	}
#	fz_catch(ctx) {
#		pdf_delete_annot(ctx, page, annot);
#
#		if (type == PDF_WIDGET_TYPE_SIGNATURE) {
#			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, old_sigflags), PDF_NAME(Root), #PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);
#        }
#
#		fz_rethrow(ctx);
#	}
#
#	return annot;
#}
#
#
#void
#JM_delete_widget(fz_context *ctx, pdf_page *page, pdf_annot *annot)
#{
#    pdf_document *doc = annot->page->doc;
#    pdf_annot **annotptr;
#    pdf_obj *annot_arr, *obj;
#    int i;
#
#    if (annot == NULL)
#        return;
#
#    // Remove widget from page's list
#    for (annotptr = &page->widgets; *annotptr; annotptr = &(*annotptr)->next) {
#        if (*annotptr == annot)
#            break;
#    }
#
#    // Check whether passed annotation was of this page
#    if (*annotptr == NULL)
#        return;
#
#    *annotptr = pdf_next_widget(gctx, (pdf_widget *) annot);
#
#    // If the removed field was the last in the list adjust the end pointer
#    if (*annotptr == NULL)
#        page->widget_tailp = annotptr;
#
#    annot_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
#    i = pdf_array_find(ctx, annot_arr, annot->obj);
#    if (i >= 0)
#        pdf_array_delete(ctx, annot_arr, i);
#
#    // remove any Popup for the field
#    obj = pdf_dict_get(ctx, annot->obj, PDF_NAME(Popup));
#    if (obj) {
#        i = pdf_array_find(ctx, annot_arr, obj);
#        if (i >= 0)
#            pdf_array_delete(ctx, annot_arr, i);
#    }
#
#    // remove field from AcroForm
#    obj = pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/Fields");
#    if (pdf_is_array(ctx, obj)) {
#        i = pdf_array_find(ctx, obj, annot->obj);
#        if (i >= 0)
#            pdf_array_delete(ctx, obj, i);
#    }
#
#    pdf_drop_annot(ctx, annot);
#    doc->dirty = 1;
#}
#
#
#
#
#
#
#
## PushButton get state
##-----------------------------------------------------------------------------
#PyObject *JM_pushbtn_state(fz_context *ctx, pdf_annot *annot)
#{   // pushed buttons do not reflect status changes in the PDF
#    // always reflect them as untouched
#    Py_RETURN_FALSE;
#}
#
## CheckBox get state
##-----------------------------------------------------------------------------
#PyObject *JM_checkbox_state(fz_context *ctx, pdf_annot *annot)
#{
#    pdf_obj *leafv = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(V));
#    pdf_obj *leafas = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(AS));
#    if (!leafv) Py_RETURN_FALSE;
#    if (leafv == PDF_NAME(Off)) Py_RETURN_FALSE;
#    if (leafv == pdf_new_name(ctx, "Yes"))
#        Py_RETURN_TRUE;
#    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Off"))
#        Py_RETURN_FALSE;
#    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Yes"))
#        Py_RETURN_TRUE;
#    if (leafas && leafas == PDF_NAME(Off)) Py_RETURN_FALSE;
#    Py_RETURN_TRUE;
#}
#
## RadioBox get state
##-----------------------------------------------------------------------------
#PyObject *JM_radiobtn_state(fz_context *ctx, pdf_annot *annot)
#{   // MuPDF treats radio buttons like check boxes - hence so do we
#    return JM_checkbox_state(ctx, annot);
#}
#
## Text field retrieve value
##-----------------------------------------------------------------------------
#PyObject *JM_text_value(fz_context *ctx, pdf_annot *annot)
#{
#    const char *text = NULL;
#    fz_var(text);
#    fz_try(ctx)
#        text = pdf_field_value(ctx, annot->obj);
#    fz_catch(ctx) Py_RETURN_NONE;
#    return JM_UnicodeFromStr(text);
#}
#
## ListBox retrieve value
##-----------------------------------------------------------------------------
#PyObject *JM_listbox_value(fz_context *ctx, pdf_annot *annot)
#{
#    int i = 0, n = 0;
#    // may be single value or array
#    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(V));
#    if (pdf_is_string(ctx, optarr))         // a single string
#        return PyString_FromString(pdf_to_text_string(ctx, optarr));
#
#    // value is an array (may have len 0)
#    n = pdf_array_len(ctx, optarr);
#    PyObject *liste = PyList_New(0);
#
#    // extract a list of strings
#    // each entry may again be an array: take second entry then
#    for (i = 0; i < n; i++) {
#        pdf_obj *elem = pdf_array_get(ctx, optarr, i);
#        if (pdf_is_array(ctx, elem))
#            elem = pdf_array_get(ctx, elem, 1);
#        LIST_APPEND_DROP(liste, JM_UnicodeFromStr(pdf_to_text_string(ctx, elem)));
#    }
#    return liste;
#}
#
## ComboBox retrieve value
##-----------------------------------------------------------------------------
#PyObject *JM_combobox_value(fz_context *ctx, pdf_annot *annot)
#{   // combobox treated like listbox
#    return JM_listbox_value(ctx, annot);
#}
#
## Signature field retrieve value
#PyObject *JM_signature_value(fz_context *ctx, pdf_annot *annot)
#{   // signatures are currently not supported
#    Py_RETURN_NONE;
#}
#
## retrieve ListBox / ComboBox choice values
##-----------------------------------------------------------------------------
#PyObject *JM_choice_options(fz_context *ctx, pdf_annot *annot)
#{   // return list of choices for list or combo boxes
#    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
#    PyObject *val;
#    int n = pdf_choice_widget_options(ctx, (pdf_widget *) annot, 0, NULL);
#    if (n == 0) Py_RETURN_NONE;                     // wrong widget type
#
#    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(Opt));
#    int i, m;
#    PyObject *liste = PyList_New(0);
#
#    for (i = 0; i < n; i++) {
#        m = pdf_array_len(ctx, pdf_array_get(ctx, optarr, i));
#        if (m == 2) {
#            val = Py_BuildValue("ss",
#            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 0)),
#            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 1)));
#            LIST_APPEND_DROP(liste, val);
#        } else {
#            val = JM_UnicodeFromStr(pdf_to_text_string(ctx, pdf_array_get(ctx, optarr, i)));
#            LIST_APPEND_DROP(liste, val);
#        }
#    }
#    return liste;
#}
#
## set ListBox / ComboBox values
##-----------------------------------------------------------------------------
#void JM_set_choice_options(fz_context *ctx, pdf_annot *annot, PyObject *liste)
#{
#    if (!liste) return;
#    if (!PySequence_Check(liste)) return;
#    Py_ssize_t i, n = PySequence_Size(liste);
#    if (n < 1) return;
#    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
#    char *opt = NULL;
#    pdf_obj *optarr = pdf_new_array(ctx, pdf, n);
#    PyObject *val = NULL;
#    for (i = 0; i < n; i++) {
#        val = PySequence_ITEM(liste, i);
#        opt = JM_StrAsChar(val);
#        pdf_array_push_text_string(ctx, optarr, (const char *) opt);
#        Py_CLEAR(val);
#    }
#
#    pdf_dict_put(ctx, annot->obj, PDF_NAME(Opt), optarr);
#    return;
#}
#
##-----------------------------------------------------------------------------
## Populate a Python Widget object with the values from a PDF form field.
## Called by "Page.firstWidget" and "Widget.next".
##-----------------------------------------------------------------------------
#void JM_get_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
#{
#    pdf_document *pdf = annot->page->doc;
#    pdf_widget *tw = (pdf_widget *) annot;
#    pdf_obj *obj = NULL, *js = NULL, *o = NULL;
#    fz_buffer *res = NULL;
#    Py_ssize_t i = 0, n = 0;
#    fz_try(ctx) {
#        int field_type = pdf_widget_type(gctx, tw);
#        SETATTR_DROP(Widget, "field_type", Py_BuildValue("i", field_type));
#        if (field_type == PDF_WIDGET_TYPE_SIGNATURE) {
#            if (pdf_signature_is_signed(ctx, pdf, annot->obj)) {
#                SETATTR("is_signed", Py_True);
#            } else {
#                SETATTR("is_signed", Py_False);
#            }
#        } else {
#            SETATTR("is_signed", Py_None);
#        }
#        SETATTR_DROP(Widget, "border_style",
#                JM_UnicodeFromStr(pdf_field_border_style(ctx, annot->obj)));
#        SETATTR_DROP(Widget, "field_type_string",
#                JM_UnicodeFromStr(JM_field_type_text(field_type)));
#
#        char *field_name = pdf_field_name(ctx, annot->obj);
#        SETATTR_DROP(Widget, "field_name", JM_UnicodeFromStr(field_name));
#        JM_Free(field_name);
#
#        const char *label = NULL;
#        obj = pdf_dict_get(ctx, annot->obj, PDF_NAME(TU));
#        if (obj) label = pdf_to_text_string(ctx, obj);
#        SETATTR_DROP(Widget, "field_label", JM_UnicodeFromStr(label));
#
#        SETATTR_DROP(Widget, "field_value",
#                JM_UnicodeFromStr(pdf_field_value(ctx, annot->obj)));
#
#        SETATTR_DROP(Widget, "field_display",
#                Py_BuildValue("i", pdf_field_display(ctx, annot->obj)));
#
#        float border_width = pdf_to_real(ctx, pdf_dict_getl(ctx, annot->obj,
#                                PDF_NAME(BS), PDF_NAME(W), NULL));
#        if (border_width == 0) border_width = 1;
#        SETATTR_DROP(Widget, "border_width",
#                Py_BuildValue("f", border_width));
#
#        obj = pdf_dict_getl(ctx, annot->obj,
#                                PDF_NAME(BS), PDF_NAME(D), NULL);
#        if (pdf_is_array(ctx, obj)) {
#            n = (Py_ssize_t) pdf_array_len(ctx, obj);
#            PyObject *d = PyList_New(n);
#            for (i = 0; i < n; i++) {
#                PyList_SET_ITEM(d, i, Py_BuildValue("i", pdf_to_int(ctx,
#                                pdf_array_get(ctx, obj, (int) i))));
#            }
#            SETATTR_DROP(Widget, "border_dashes", d);
#        }
#
#        SETATTR_DROP(Widget, "text_maxlen",
#                Py_BuildValue("i", pdf_text_widget_max_len(ctx, tw)));
#
#        SETATTR_DROP(Widget, "text_format",
#                Py_BuildValue("i", pdf_text_widget_format(ctx, tw)));
#
#        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BG), NULL);
#        if (pdf_is_array(ctx, obj)) {
#            n = (Py_ssize_t) pdf_array_len(ctx, obj);
#            PyObject *col = PyList_New(n);
#            for (i = 0; i < n; i++) {
#                PyList_SET_ITEM(col, i, Py_BuildValue("f",
#                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
#            }
#            SETATTR_DROP(Widget, "fill_color", col);
#        }
#
#        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BC), NULL);
#        if (pdf_is_array(ctx, obj)) {
#            n = (Py_ssize_t) pdf_array_len(ctx, obj);
#            PyObject *col = PyList_New(n);
#            for (i = 0; i < n; i++) {
#                PyList_SET_ITEM(col, i, Py_BuildValue("f",
#                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
#            }
#            SETATTR_DROP(Widget, "border_color", col);
#        }
#
#        SETATTR_DROP(Widget, "choice_values", JM_choice_options(ctx, annot));
#
#        const char *da = pdf_to_text_string(ctx, pdf_dict_get_inheritable(ctx,
#                                        annot->obj, PDF_NAME(DA)));
#        SETATTR_DROP(Widget, "_text_da", JM_UnicodeFromStr(da));
#
#        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(CA), NULL);
#        if (obj) {
#            SETATTR_DROP(Widget, "button_caption",
#                    JM_UnicodeFromStr((char *)pdf_to_text_string(ctx, obj)));
#        }
#
#        SETATTR_DROP(Widget, "field_flags",
#                Py_BuildValue("i", pdf_field_flags(ctx, annot->obj)));
#
#        // call Py method to reconstruct text color, font name, size
#        PyObject *call = CALLATTR("_parse_da", NULL);
#        Py_XDECREF(call);
#
#        // extract JavaScript action texts
#        SETATTR_DROP(Widget, "script",
#            JM_get_script(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME(A))));
#
#        SETATTR_DROP(Widget, "script_stroke",
#            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), NULL)));
#
#        SETATTR_DROP(Widget, "script_format",
#            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), NULL)));
#
#        SETATTR_DROP(Widget, "script_change",
#            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), NULL)));
#
#        SETATTR_DROP(Widget, "script_calc",
#            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), NULL)));
#    }
#    fz_always(ctx) PyErr_Clear();
#    fz_catch(ctx) fz_rethrow(ctx);
#    return;
#}
#
#
##-----------------------------------------------------------------------------
## Update the PDF form field with the properties from a Python Widget object.
## Called by "Page.addWidget" and "Annot.updateWidget".
##-----------------------------------------------------------------------------
#void JM_set_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
#{
#    pdf_document *pdf = annot->page->doc;
#    pdf_page *page = annot->page;
#    fz_rect rect;
#    pdf_obj *fill_col = NULL, *border_col = NULL;
#    pdf_obj *dashes = NULL;
#    Py_ssize_t i, n = 0;
#    int d;
#    int result = 0;
#    PyObject *value = GETATTR("field_type");
#    int field_type = (int) PyInt_AsLong(value);
#    Py_DECREF(value);
#
#    // rectangle --------------------------------------------------------------
#    value = GETATTR("rect");
#    rect = JM_rect_from_py(value);
#    Py_XDECREF(value);
#    fz_matrix rot_mat = JM_rotate_page_matrix(ctx, page);
#    rect = fz_transform_rect(rect, rot_mat);
#    pdf_set_annot_rect(ctx, annot, rect);
#
#    // fill color -------------------------------------------------------------
#    value = GETATTR("fill_color");
#    if (value && PySequence_Check(value)) {
#        n = PySequence_Size(value);
#        fill_col = pdf_new_array(ctx, pdf, n);
#        float col = 0;
#        for (i = 0; i < n; i++) {
#            JM_FLOAT_ITEM(value, i, &col);
#            pdf_array_push_real(ctx, fill_col, col);
#        }
#        pdf_field_set_fill_color(ctx, annot->obj, fill_col);
#        pdf_drop_obj(ctx, fill_col);
#    }
#    Py_XDECREF(value);
#
#    // dashes -----------------------------------------------------------------
#    value = GETATTR("border_dashes");
#    if (value && PySequence_Check(value)) {
#        n = PySequence_Size(value);
#        dashes = pdf_new_array(ctx, pdf, n);
#        for (i = 0; i < n; i++) {
#            pdf_array_push_int(ctx, dashes,
#                               (int64_t) PyInt_AsLong(PySequence_ITEM(value, i)));
#        }
#        pdf_dict_putl_drop(ctx, annot->obj, dashes,
#                                PDF_NAME(BS),
#                                PDF_NAME(D),
#                                NULL);
#    }
#    Py_XDECREF(value);
#
#    // border color -----------------------------------------------------------
#    value = GETATTR("border_color");
#    if (value && PySequence_Check(value)) {
#        n = PySequence_Size(value);
#        border_col = pdf_new_array(ctx, pdf, n);
#        float col = 0;
#        for (i = 0; i < n; i++) {
#            JM_FLOAT_ITEM(value, i, &col);
#            pdf_array_push_real(ctx, border_col, col);
#        }
#        pdf_dict_putl_drop(ctx, annot->obj, border_col,
#                                PDF_NAME(MK),
#                                PDF_NAME(BC),
#                                NULL);
#    }
#    Py_XDECREF(value);
#
#    // entry ignored - may be used later
#    /*
#    int text_format = (int) PyInt_AsLong(GETATTR("text_format"));
#    */
#
#    // field label -----------------------------------------------------------
#    value = GETATTR("field_label");
#    if (value != Py_None) {
#        char *label = JM_StrAsChar(value);
#        pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(TU), label);
#    }
#    Py_XDECREF(value);
#
#    // field name -------------------------------------------------------------
#    value = GETATTR("field_name");
#    if (value != Py_None) {
#        char *name = JM_StrAsChar(value);
#        char *old_name = pdf_field_name(ctx, annot->obj);
#        if (strcmp(name, old_name) != 0) {
#            pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(T), name);
#        }
#        JM_Free(old_name);
#    }
#    Py_XDECREF(value);
#
#    // max text len -----------------------------------------------------------
#    if (field_type == PDF_WIDGET_TYPE_TEXT)
#    {
#        value = GETATTR("text_maxlen");
#        int text_maxlen = (int) PyInt_AsLong(value);
#        if (text_maxlen) {
#            pdf_dict_put_int(ctx, annot->obj, PDF_NAME(MaxLen), text_maxlen);
#        }
#        Py_XDECREF(value);
#    }
#    value = GETATTR("field_display");
#    d = (int) PyInt_AsLong(value);
#    Py_XDECREF(value);
#    pdf_field_set_display(ctx, annot->obj, d);
#
#    // choice values ----------------------------------------------------------
#    if (field_type == PDF_WIDGET_TYPE_LISTBOX ||
#        field_type == PDF_WIDGET_TYPE_COMBOBOX) {
#        value = GETATTR("choice_values");
#        JM_set_choice_options(ctx, annot, value);
#        Py_XDECREF(value);
#    }
#
#    // border style -----------------------------------------------------------
#    value = GETATTR("border_style");
#    pdf_obj *val = JM_get_border_style(ctx, value);
#    Py_XDECREF(value);
#    pdf_dict_putl_drop(ctx, annot->obj, val,
#                            PDF_NAME(BS),
#                            PDF_NAME(S),
#                            NULL);
#
#    // border width -----------------------------------------------------------
#    value = GETATTR("border_width");
#    float border_width = (float) PyFloat_AsDouble(value);
#    Py_XDECREF(value);
#    pdf_dict_putl_drop(ctx, annot->obj, pdf_new_real(ctx, border_width),
#                            PDF_NAME(BS),
#                            PDF_NAME(W),
#                            NULL);
#
#    // /DA string -------------------------------------------------------------
#    value = GETATTR("_text_da");
#    char *da = JM_StrAsChar(value);
#    Py_XDECREF(value);
#    pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(DA), da);
#    pdf_dict_del(ctx, annot->obj, PDF_NAME(DS)); /* not supported by MuPDF */
#    pdf_dict_del(ctx, annot->obj, PDF_NAME(RC)); /* not supported by MuPDF */
#
#    // field flags ------------------------------------------------------------
#    int field_flags = 0, Ff = 0;
#    if (field_type != PDF_WIDGET_TYPE_CHECKBOX) {
#        value = GETATTR("field_flags");
#        field_flags = (int) PyInt_AsLong(value);
#        if (!PyErr_Occurred()) {
#            Ff = pdf_field_flags(ctx, annot->obj);
#            Ff |= field_flags;
#        }
#        Py_XDECREF(value);
#    }
#    pdf_dict_put_int(ctx, annot->obj, PDF_NAME(Ff), Ff);
#
#    // button caption ---------------------------------------------------------
#    value = GETATTR("button_caption");
#    char *ca = JM_StrAsChar(value);
#    if (ca) {
#        pdf_field_set_button_caption(ctx, annot->obj, ca);
#    }
#    Py_XDECREF(value);
#
#    // script (/A) -------------------------------------------------------
#    value = GETATTR("script");
#    JM_put_script(ctx, annot->obj, PDF_NAME(A), NULL, value);
#    Py_CLEAR(value);
#
#    // script (/AA/K) -------------------------------------------------------
#    value = GETATTR("script_stroke");
#    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), value);
#    Py_CLEAR(value);
#
#    // script (/AA/F) -------------------------------------------------------
#    value = GETATTR("script_format");
#    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), value);
#    Py_CLEAR(value);
#
#    // script (/AA/V) -------------------------------------------------------
#    value = GETATTR("script_change");
#    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), value);
#    Py_CLEAR(value);
#
#    // script (/AA/C) -------------------------------------------------------
#    value = GETATTR("script_calc");
#    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), value);
#    Py_CLEAR(value);
#
#    // field value ------------------------------------------------------------
#    value = GETATTR("field_value");
#    char *text = NULL;
#    switch(field_type)
#    {
#    case PDF_WIDGET_TYPE_CHECKBOX:
#    case PDF_WIDGET_TYPE_RADIOBUTTON:
#        if (PyObject_RichCompareBool(value, Py_True, Py_EQ)) {
#            pdf_obj *onstate = pdf_button_field_on_state(ctx, annot->obj);
#            const char *on = pdf_to_name(ctx, onstate);
#            result = pdf_set_field_value(ctx, pdf, annot->obj, on, 1);
#            pdf_dict_put_name(ctx, annot->obj, PDF_NAME(V), on);
#        } else {
#            result = pdf_set_field_value(ctx, pdf, annot->obj, "Off", 1);
#            pdf_dict_put(ctx, annot->obj, PDF_NAME(V), PDF_NAME(Off));
#        }
#        break;
#    default:
#        text = JM_StrAsChar(value);
#        if (text) {
#            result = pdf_set_field_value(ctx, pdf, annot->obj, (const char *)text, 1);
#        }
#    }
#    Py_CLEAR(value);
#    PyErr_Clear();
#    pdf_dirty_annot(ctx, annot);
#    annot->is_hot = 1;
#    annot->is_active = 1;
#    pdf_update_appearance(ctx, annot);
#}
##undef SETATTR
##undef GETATTR
##undef CALLATTR
#
#
##-----------------------------------------------------------------------------
## perform some cleaning if we have /EmbeddedFiles:
## (1) remove any /Limits if /Names exists
## (2) remove any empty /Collection
## (3) set /PageMode/UseAttachments
##-----------------------------------------------------------------------------
#void JM_embedded_clean(fz_context *ctx, pdf_document *pdf)
#{
#    pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));
#
#    // remove any empty /Collection entry
#    pdf_obj *coll = pdf_dict_get(ctx, root, PDF_NAME(Collection));
#    if (coll && pdf_dict_len(ctx, coll) == 0)
#        pdf_dict_del(ctx, root, PDF_NAME(Collection));
#
#    pdf_obj *efiles = pdf_dict_getl(ctx, root,
#                                    PDF_NAME(Names),
#                                    PDF_NAME(EmbeddedFiles),
#                                    PDF_NAME(Names),
#                                    NULL);
#    if (efiles) {
#        pdf_dict_put_name(ctx, root, PDF_NAME(PageMode), "UseAttachments");
#    }
#    return;
#}
#
##-----------------------------------------------------------------------------
## embed a new file in a PDF (not only /EmbeddedFiles entries)
##-----------------------------------------------------------------------------
#pdf_obj *JM_embed_file(fz_context *ctx,
#                       pdf_document *pdf,
#                       fz_buffer *buf,
#                       char *filename,
#                       char *ufilename,
#                       char *desc,
#                       int compress)
#{
#    size_t len = 0;
#    pdf_obj *ef, *f, *params, *val = NULL;
#    fz_var(val);
#    fz_try(ctx) {
#        val = pdf_new_dict(ctx, pdf, 6);
#        pdf_dict_put_dict(ctx, val, PDF_NAME(CI), 4);
#        ef = pdf_dict_put_dict(ctx, val, PDF_NAME(EF), 4);
#        pdf_dict_put_text_string(ctx, val, PDF_NAME(F), filename);
#        pdf_dict_put_text_string(ctx, val, PDF_NAME(UF), ufilename);
#        pdf_dict_put_text_string(ctx, val, PDF_NAME(Desc), desc);
#        pdf_dict_put(ctx, val, PDF_NAME(Type), PDF_NAME(Filespec));
#        f = pdf_add_stream(ctx, pdf,
#                           fz_new_buffer_from_copied_data(ctx, "  ", 1),
#                           NULL, 0);
#        pdf_dict_put_drop(ctx, ef, PDF_NAME(F), f);
#        JM_update_stream(ctx, pdf, f, buf, compress);
#        len = fz_buffer_storage(ctx, buf, NULL);
#        pdf_dict_put_int(ctx, f, PDF_NAME(DL), len);
#        pdf_dict_put_int(ctx, f, PDF_NAME(Length), len);
#        params = pdf_dict_put_dict(ctx, f, PDF_NAME(Params), 4);
#        pdf_dict_put_int(ctx, params, PDF_NAME(Size), len);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return val;
#}
#
#
##----------------------------------------------------------------------------
## Helpers for document page selection - main logic was imported
## from pdf_clean_file.c. But instead of analyzing a string-based spec of
## selected pages, we accept a Python sequence.
##----------------------------------------------------------------------------
#typedef struct globals_s
#{
#    pdf_document *doc;
#    fz_context *ctx;
#} globals;
#
#int string_in_names_list(fz_context *ctx, pdf_obj *p, pdf_obj *names_list)
#{
#    int n = pdf_array_len(ctx, names_list);
#    int i;
#    const char *str = pdf_to_text_string(ctx, p);
#
#    for (i = 0; i < n ; i += 2)
#    {
#        if (!strcmp(pdf_to_text_string(ctx, pdf_array_get(ctx, names_list, i)), str))
#            return 1;
#    }
#    return 0;
#}
#
##----------------------------------------------------------------------------
## Recreate page tree to only retain specified pages.
##----------------------------------------------------------------------------
#void retainpage(fz_context *ctx, pdf_document *doc, pdf_obj *parent, pdf_obj *kids, int page)
#{
#    pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, page);
#
#    pdf_flatten_inheritable_page_items(ctx, pageref);
#
#    pdf_dict_put(ctx, pageref, PDF_NAME(Parent), parent);
#
#    /* Store page object in new kids array */
#    pdf_array_push(ctx, kids, pageref);
#}
#
#int dest_is_valid_page(fz_context *ctx, pdf_obj *obj, int *page_object_nums, int pagecount)
#{
#    int i;
#    int num = pdf_to_num(ctx, obj);
#
#    if (num == 0)
#        return 0;
#    for (i = 0; i < pagecount; i++)
#    {
#        if (page_object_nums[i] == num)
#            return 1;
#    }
#    return 0;
#}
#
#int dest_is_valid(fz_context *ctx, pdf_obj *o, int page_count, int *page_object_nums, pdf_obj #*names_list)
#{
#    pdf_obj *p;
#
#    p = pdf_dict_get(ctx, o, PDF_NAME(A));
#    if (pdf_name_eq(ctx, pdf_dict_get(ctx, p, PDF_NAME(S)), PDF_NAME(GoTo)) &&
#        !string_in_names_list(ctx, pdf_dict_get(ctx, p, PDF_NAME(D)), names_list))
#        return 0;
#
#    p = pdf_dict_get(ctx, o, PDF_NAME(Dest));
#    if (p == NULL)
#    {}
#    else if (pdf_is_string(ctx, p))
#    {
#        return string_in_names_list(ctx, p, names_list);
#    }
#    else if (!dest_is_valid_page(ctx, pdf_array_get(ctx, p, 0), page_object_nums, page_count))
#        return 0;
#
#    return 1;
#}
#
#int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int #*page_object_nums, pdf_obj *names_list);
#
#int strip_outline(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int #*page_object_nums, pdf_obj *names_list, pdf_obj **pfirst, pdf_obj **plast)
#{
#    pdf_obj *prev = NULL;
#    pdf_obj *first = NULL;
#    pdf_obj *current;
#    int count = 0;
#
#    for (current = outlines; current != NULL; )
#    {
#        int nc;
#
#        /*********************************************************************/
#        // Strip any children to start with. This takes care of
#        // First / Last / Count for us.
#        /*********************************************************************/
#        nc = strip_outlines(ctx, doc, current, page_count, page_object_nums, names_list);
#
#        if (!dest_is_valid(ctx, current, page_count, page_object_nums, names_list))
#        {
#            if (nc == 0)
#            {
#                /*************************************************************/
#                // Outline with invalid dest and no children. Drop it by
#                // pulling the next one in here.
#                /*************************************************************/
#                pdf_obj *next = pdf_dict_get(ctx, current, PDF_NAME(Next));
#                if (next == NULL)
#                {
#                    // There is no next one to pull in
#                    if (prev != NULL)
#                        pdf_dict_del(ctx, prev, PDF_NAME(Next));
#                }
#                else if (prev != NULL)
#                {
#                    pdf_dict_put(ctx, prev, PDF_NAME(Next), next);
#                    pdf_dict_put(ctx, next, PDF_NAME(Prev), prev);
#                }
#                else
#                {
#                    pdf_dict_del(ctx, next, PDF_NAME(Prev));
#                }
#                current = next;
#            }
#            else
#            {
#                // Outline with invalid dest, but children. Just drop the dest.
#                pdf_dict_del(ctx, current, PDF_NAME(Dest));
#                pdf_dict_del(ctx, current, PDF_NAME(A));
#                current = pdf_dict_get(ctx, current, PDF_NAME(Next));
#            }
#        }
#        else
#        {
#            // Keep this one
#            if (first == NULL)
#                first = current;
#            prev = current;
#            current = pdf_dict_get(ctx, current, PDF_NAME(Next));
#            count++;
#        }
#    }
#
#    *pfirst = first;
#    *plast = prev;
#
#    return count;
#}
#
#int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int #*page_object_nums, pdf_obj *names_list)
#{
#    int nc;
#    pdf_obj *first;
#    pdf_obj *last;
#
#    if (outlines == NULL)
#        return 0;
#
#    first = pdf_dict_get(ctx, outlines, PDF_NAME(First));
#    if (first == NULL)
#        nc = 0;
#    else
#        nc = strip_outline(ctx, doc, first, page_count, page_object_nums,
#                           names_list, &first, &last);
#
#    if (nc == 0)
#    {
#        pdf_dict_del(ctx, outlines, PDF_NAME(First));
#        pdf_dict_del(ctx, outlines, PDF_NAME(Last));
#        pdf_dict_del(ctx, outlines, PDF_NAME(Count));
#    }
#    else
#    {
#        int old_count = pdf_to_int(ctx, pdf_dict_get(ctx, outlines, PDF_NAME(Count)));
#        pdf_dict_put(ctx, outlines, PDF_NAME(First), first);
#        pdf_dict_put(ctx, outlines, PDF_NAME(Last), last);
#        pdf_dict_put_drop(ctx, outlines, PDF_NAME(Count), pdf_new_int(ctx, old_count > 0 ? nc : -nc));
#    }
#    return nc;
#}
#
##----------------------------------------------------------------------------
##   This is called by PyMuPDF:
##   liste = page numbers to retain
##----------------------------------------------------------------------------
#void retainpages(fz_context *ctx, globals *glo, PyObject *liste)
#{
#    pdf_obj *oldroot, *root, *pages, *kids, *countobj, *olddests;
#    Py_ssize_t argc = PySequence_Size(liste);
#    pdf_document *doc = glo->doc;
#    pdf_obj *names_list = NULL;
#    pdf_obj *outlines;
#    pdf_obj *ocproperties;
#    int pagecount = pdf_count_pages(ctx, doc);
#
#    int i;
#    int *page_object_nums;
#
#/******************************************************************************/
##    Keep only pages/type and (reduced) dest entries to avoid
##    references to dropped pages
#/******************************************************************************/
#    oldroot = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
#    pages = pdf_dict_get(ctx, oldroot, PDF_NAME(Pages));
#    olddests = pdf_load_name_tree(ctx, doc, PDF_NAME(Dests));
#    outlines = pdf_dict_get(ctx, oldroot, PDF_NAME(Outlines));
#    ocproperties = pdf_dict_get(ctx, oldroot, PDF_NAME(OCProperties));
#
#    root = pdf_new_dict(ctx, doc, 3);
#    pdf_dict_put(ctx, root, PDF_NAME(Type), pdf_dict_get(ctx, oldroot, PDF_NAME(Type)));
#    pdf_dict_put(ctx, root, PDF_NAME(Pages), pdf_dict_get(ctx, oldroot, PDF_NAME(Pages)));
#    if (outlines)
#        pdf_dict_put(ctx, root, PDF_NAME(Outlines), outlines);
#    if (ocproperties)
#        pdf_dict_put(ctx, root, PDF_NAME(OCProperties), ocproperties);
#
#    pdf_update_object(ctx, doc, pdf_to_num(ctx, oldroot), root);
#
#    // Create a new kids array with only the pages we want to keep
#    kids = pdf_new_array(ctx, doc, 1);
#
#    // Retain pages specified
#    Py_ssize_t page;
#    fz_try(ctx) {
#        for (page = 0; page < argc; page++) {
#            i = (int) PyInt_AsLong(PySequence_ITEM(liste, page));
#            if (i < 0 or i >= pagecount)
#                THROWMSG(ctx, "invalid page number(s)");
#            retainpage(ctx, doc, pages, kids, i);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#
#    // Update page count and kids array
#    countobj = pdf_new_int(ctx, pdf_array_len(ctx, kids));
#    pdf_dict_put_drop(ctx, pages, PDF_NAME(Count), countobj);
#    pdf_dict_put_drop(ctx, pages, PDF_NAME(Kids), kids);
#
#    pagecount = pdf_count_pages(ctx, doc);
#    page_object_nums = fz_calloc(ctx, pagecount, sizeof(*page_object_nums));
#    for (i = 0; i < pagecount; i++)
#    {
#        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);
#        page_object_nums[i] = pdf_to_num(ctx, pageref);
#    }
#
#/******************************************************************************/
## If we had an old Dests tree (now reformed as an olddests dictionary),
## keep any entries in there that point to valid pages.
## This may mean we keep more than we need, but it is safe at least.
#/******************************************************************************/
#    if (olddests)
#    {
#        pdf_obj *names = pdf_new_dict(ctx, doc, 1);
#        pdf_obj *dests = pdf_new_dict(ctx, doc, 1);
#        int len = pdf_dict_len(ctx, olddests);
#
#        names_list = pdf_new_array(ctx, doc, 32);
#
#        for (i = 0; i < len; i++)
#        {
#            pdf_obj *key = pdf_dict_get_key(ctx, olddests, i);
#            pdf_obj *val = pdf_dict_get_val(ctx, olddests, i);
#            pdf_obj *dest = pdf_dict_get(ctx, val, PDF_NAME(D));
#
#            dest = pdf_array_get(ctx, dest ? dest : val, 0);
#            if (dest_is_valid_page(ctx, dest, page_object_nums, pagecount))
#            {
#                pdf_obj *key_str = pdf_new_string(ctx, pdf_to_name(ctx, key), strlen(pdf_to_name(ctx, #key)));
#                pdf_array_push_drop(ctx, names_list, key_str);
#                pdf_array_push(ctx, names_list, val);
#            }
#        }
#
#        pdf_dict_put(ctx, dests, PDF_NAME(Names), names_list);
#        pdf_dict_put(ctx, names, PDF_NAME(Dests), dests);
#        pdf_dict_put(ctx, root, PDF_NAME(Names), names);
#
#        pdf_drop_obj(ctx, names);
#        pdf_drop_obj(ctx, dests);
#        pdf_drop_obj(ctx, olddests);
#    }
#
#/*****************************************************************************/
## Edit each pages /Annot list to remove any links pointing to nowhere.
#/*****************************************************************************/
#    for (i = 0; i < pagecount; i++)
#    {
#        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);
#
#        pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));
#
#        int len = pdf_array_len(ctx, annots);
#        int j;
#
#        for (j = 0; j < len; j++)
#        {
#            pdf_obj *o = pdf_array_get(ctx, annots, j);
#
#            if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
#                continue;
#
#            if (!dest_is_valid(ctx, o, pagecount, page_object_nums, names_list))
#            {
#                // Remove this annotation
#                pdf_array_delete(ctx, annots, j);
#                len--;
#                j--;
#            }
#        }
#    }
#
#    if (strip_outlines(ctx, doc, outlines, pagecount, page_object_nums, names_list) == 0)
#    {
#        pdf_dict_del(ctx, root, PDF_NAME(Outlines));
#    }
#
#    fz_free(ctx, page_object_nums);
#    pdf_drop_obj(ctx, names_list);
#    pdf_drop_obj(ctx, root);
#}
#
#def remove_dest_range(pdf, first, last):
#
#    pagecount = mpdf_count_pages(pdf)
#    if (not INRANGE(first, 0, pagecount-1)
#            or not INRANGE(last, 0, pagecount-1)
#            or first > last
#            ):
#        return
#    try:
#        for i in range(pagecount):
#            if INRANGE(i, first, last):
#                continue
#
#            pageref = mpdf_lookup_page_obj(pdf, i)
#            annots = mpdf_dict_get(pageref, PDF_NAME(Annots))
#            if not annots.m_internal:
#                continue
#            len_ = mpdf_array_len(annots)
#            for j in range(len - 1, -1, -1):
#                o = mpdf_array_get(annots, j)
#                if not mpdf_name_eq(mpdf_dict_get(o, PDF_NAME(Subtype)), PDF_NAME(Link)):
#                    continue
#                action = mpdf_dict_get(o, PDF_NAME(A))
#                dest =  mpdf_dict_get(o, PDF_NAME(Dest))
#                action.m_internal:
#                    if not mpdf_name_eq(mpdf_dict_get(action, PDF_NAME(S)), PDF_NAME(GoTo)):
#                        continue
#                    dest = mpdf_dict_get(action, PDF_NAME(D))
#                }
#                pno = -1
#                if mpdf_is_array(dest):
#                    target = mpdf_array_get(dest, 0)
#                    pno = mpdf_lookup_page_number(pdf, target)
#                }
#                elif mpdf_is_string(dest):
#                    pno = mpdf_lookup_anchor(pdf, pdf_to_text_string(ctx, dest), None, None)
#                }
#                if INRANGE(pno, first, last):
#                    mpdf_array_delete(annots, j)
#    except Exception:
#        pass
#
#
##-----------------------------------------------------------------------------
## Read and concatenate a PDF page's /Conents object(s) in a buffer
##-----------------------------------------------------------------------------
#def JM_read_contents(pageref):
#    fz_buffer *res = NULL, *nres = NULL;
#    int i;
#    try:
#        contents = mpdf_dict_get(pageref, PDF_NAME(Contents))
#        if mpdf_is_array(, contents):
#            res = mfz_new_buffer(1024)
#            for i in range(mpdf_array_len(contents)):
#                nres = mpdf_load_stream(mpdf_array_get(contents, i))
#                mfz_append_buffer(res, nres)
#        elif contents.m_internal:
#            res = mpdf_load_stream(contents)
#    except Exception:
#        raise
#    return res
#
##-----------------------------------------------------------------------------
## Make an XObject from a PDF page
## For a positive xref assume that that object can be used instead
##-----------------------------------------------------------------------------
#pdf_obj *JM_xobject_from_page(fz_context * ctx, pdf_document * pdfout, fz_page * fsrcpage, int xref, #pdf_graft_map *gmap)
#{
#    pdf_obj *xobj1, *resources = NULL, *o, *spageref;
#    fz_try(ctx) {
#        if (xref > 0) {
#            xobj1 = pdf_new_indirect(ctx, pdfout, xref, 0);
#        } else {
#            fz_buffer *res = NULL;
#            fz_rect mediabox;
#            pdf_page *srcpage = pdf_page_from_fz_page(ctx, fsrcpage);
#            spageref = srcpage->obj;
#            mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(MediaBox)));
#            // Deep-copy resources object of source page
#            o = pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(Resources));
#            if (gmap) // use graftmap when possible
#                resources = pdf_graft_mapped_object(ctx, gmap, o);
#            else
#                resources = pdf_graft_object(ctx, pdfout, o);
#
#            // get spgage contents source
#            res = JM_read_contents(ctx, spageref);
#
#            //-------------------------------------------------------------
#            // create XObject representing the source page
#            //-------------------------------------------------------------
#            xobj1 = pdf_new_xobject(ctx, pdfout, mediabox, fz_identity, NULL, res);
#            // store spage contents
#            JM_update_stream(ctx, pdfout, xobj1, res, 1);
#            fz_drop_buffer(ctx, res);
#
#            // store spage resources
#            pdf_dict_put_drop(ctx, xobj1, PDF_NAME(Resources), resources);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return xobj1;
#}
#
##-----------------------------------------------------------------------------
## Insert a buffer as a new separate /Contents object of a page.
## 1. Create a new stream object from buffer 'newcont'
## 2. If /Contents already is an array, then just prepend or append this object
## 3. Else, create new array and put old content obj and this object into it.
##    If the page had no /Contents before, just create a 1-item array.
##-----------------------------------------------------------------------------
#int JM_insert_contents(fz_context * ctx, pdf_document * pdf,
#                        pdf_obj * pageref, fz_buffer * newcont, int overlay)
#{
#    int xref = 0;
#    fz_try(ctx) {
#        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
#        pdf_obj *newconts = pdf_add_stream(ctx, pdf, newcont, NULL, 0);
#        xref = pdf_to_num(ctx, newconts);
#        if (pdf_is_array(ctx, contents)) {
#            if (overlay) // append new object
#                pdf_array_push(ctx, contents, newconts);
#            else // prepend new object
#                pdf_array_insert(ctx, contents, newconts, 0);
#        } else {
#            pdf_obj *carr = pdf_new_array(ctx, pdf, 5);
#            if (overlay) {
#                if (contents)
#                    pdf_array_push(ctx, carr, contents);
#                pdf_array_push(ctx, carr, newconts);
#            } else {
#                pdf_array_push_drop(ctx, carr, newconts);
#                if (contents)
#                    pdf_array_push(ctx, carr, contents);
#            }
#            pdf_dict_put(ctx, pageref, PDF_NAME(Contents), carr);
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return xref;
#}
#
#static PyObject *img_info = NULL;
#
#static fz_image *
#JM_image_filter(fz_context * ctx, void *opaque, fz_matrix ctm, const char *name, fz_image *image)
#{
#    fz_quad q = fz_transform_quad(fz_quad_from_rect(fz_unit_rect), ctm);
#    PyObject *q_py = JM_py_from_quad(q);
#    PyList_Append(img_info, Py_BuildValue("sO", name, q_py));
#    Py_DECREF(q_py);
#    return NULL;
#}
#
#void
#JM_filter_content_stream(
#    fz_context * ctx,
#    pdf_document * doc,
#    pdf_obj * in_stm,
#    pdf_obj * in_res,
#    fz_matrix transform,
#    pdf_filter_options * filter,
#    int struct_parents,
#    fz_buffer **out_buf,
#    pdf_obj **out_res)
#{
#    pdf_processor *proc_buffer = NULL;
#    pdf_processor *proc_filter = NULL;
#
#    fz_var(proc_buffer);
#    fz_var(proc_filter);
#
#    *out_buf = NULL;
#    *out_res = NULL;
#
#    fz_try(ctx) {
#		*out_buf = fz_new_buffer(ctx, 1024);
#		proc_buffer = pdf_new_buffer_processor(ctx, *out_buf, filter->ascii);
#		if (filter->sanitize) {
#			*out_res = pdf_new_dict(ctx, doc, 1);
#			proc_filter = pdf_new_filter_processor(ctx, doc, proc_buffer, in_res, *out_res, #struct_parents, transform, filter);
#			pdf_process_contents(ctx, proc_filter, doc, in_res, in_stm, NULL);
#			pdf_close_processor(ctx, proc_filter);
#		} else {
#			*out_res = pdf_keep_obj(ctx, in_res);
#			pdf_process_contents(ctx, proc_buffer, doc, in_res, in_stm, NULL);
#		}
#		pdf_close_processor(ctx, proc_buffer);
#    }
#    fz_always(ctx) {
#        pdf_drop_processor(ctx, proc_filter);
#        pdf_drop_processor(ctx, proc_buffer);
#    }
#    fz_catch(ctx) {
#        fz_drop_buffer(ctx, *out_buf);
#        *out_buf = NULL;
#        pdf_drop_obj(ctx, *out_res);
#        *out_res = NULL;
#        fz_rethrow(ctx);
#    }
#}
#
#PyObject *
#JM_image_reporter(fz_context *ctx, pdf_page *page)
#{
#    pdf_document *doc = page->doc;
#    pdf_filter_options filter;
#    memset(&filter, 0, sizeof filter);
#    filter.opaque = page;
#    filter.text_filter = NULL;
#    filter.image_filter = JM_image_filter;
#    filter.end_page = NULL;
#    filter.recurse = 0;
#    filter.instance_forms = 1;
#    filter.sanitize = 1;
#    filter.ascii = 1;
#
#    pdf_obj *contents, *old_res;
#    pdf_obj *struct_parents_obj;
#    pdf_obj *new_res;
#    fz_buffer *buffer;
#    int struct_parents;
#
#    struct_parents_obj = pdf_dict_get(ctx, page->obj, PDF_NAME(StructParents));
#    struct_parents = -1;
#    if (pdf_is_number(ctx, struct_parents_obj))
#        struct_parents = pdf_to_int(ctx, struct_parents_obj);
#
#    contents = pdf_page_contents(ctx, page);
#    old_res = pdf_page_resources(ctx, page);
#    img_info = PyList_New(0);
#    JM_filter_content_stream(ctx, doc, contents, old_res, fz_identity, &filter, struct_parents, &buffer, #&new_res);
#    fz_drop_buffer(ctx, buffer);
#    pdf_drop_obj(ctx, new_res);
#    PyObject *rc = PySequence_Tuple(img_info);
#    Py_DECREF(img_info);
#    img_info = NULL;
#    return rc;
#}
#
#
#
#
##------------------------------------------------------------------------
## Store ID in PDF trailer
##------------------------------------------------------------------------
#void JM_ensure_identity(fz_context *ctx, pdf_document *pdf)
#{
#    unsigned char rnd[16];
#    pdf_obj *id;
#    id = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(ID));
#    if (!id) {
#        fz_memrnd(ctx, rnd, nelem(rnd));
#        id = pdf_dict_put_array(ctx, pdf_trailer(ctx, pdf), PDF_NAME(ID), 2);
#        pdf_array_push_drop(ctx, id, pdf_new_string(ctx, (char *) rnd + 0, nelem(rnd)));
#        pdf_array_push_drop(ctx, id, pdf_new_string(ctx, (char *) rnd + 0, nelem(rnd)));
#    }
#}
#
#
##------------------------------------------------------------------------
## Ensure OCProperties, return /OCProperties key
##------------------------------------------------------------------------
#pdf_obj *
#JM_ensure_ocproperties(fz_context *ctx, pdf_document *pdf)
#{
#    pdf_obj *D, *ocp;
#    fz_try(ctx) {
#        ocp = pdf_dict_get(ctx, pdf_dict_get(gctx, pdf_trailer(ctx, pdf), PDF_NAME(Root)), #PDF_NAME(OCProperties));
#        if (ocp) goto finished;
#        pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));
#        ocp = pdf_dict_put_dict(ctx, root, PDF_NAME(OCProperties), 2);
#        pdf_dict_put_array(ctx, ocp, PDF_NAME(OCGs), 0);
#        D = pdf_dict_put_dict(ctx, ocp, PDF_NAME(D), 5);
#        pdf_dict_put_array(ctx, D, PDF_NAME(ON), 0);
#        pdf_dict_put_array(ctx, D, PDF_NAME(OFF), 0);
#        pdf_dict_put_array(ctx, D, PDF_NAME(Order), 0);
#        pdf_dict_put_array(ctx, D, PDF_NAME(RBGroups), 0);
#    finished:;
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return ocp;
#}
#
#
##------------------------------------------------------------------------
## Add OC configuration to the PDF catalog
##------------------------------------------------------------------------
#void
#JM_add_layer_config(fz_context *ctx, pdf_document *pdf, char *name, char *creator, PyObject *ON)
#{
#    pdf_obj *D, *ocp, *configs;
#    fz_try(ctx) {
#        ocp = JM_ensure_ocproperties(ctx, pdf);
#        configs = pdf_dict_get(ctx, ocp, PDF_NAME(Configs));
#        if (!pdf_is_array(ctx, configs)) {
#            configs = pdf_dict_put_array(ctx,ocp, PDF_NAME(Configs), 1);
#        }
#        D = pdf_new_dict(ctx, pdf, 5);
#        pdf_dict_put_text_string(ctx, D, PDF_NAME(Name), name);
#        if (creator) {
#            pdf_dict_put_text_string(ctx, D, PDF_NAME(Creator), creator);
#        }
#        pdf_dict_put(ctx, D, PDF_NAME(BaseState), PDF_NAME(OFF));
#        pdf_obj *onarray = pdf_dict_put_array(ctx, D, PDF_NAME(ON), 5);
#        if (!EXISTS(ON) or !PySequence_Check(ON) or !PySequence_Size(ON)) {
#            ;
#        } else {
#            pdf_obj *ocgs = pdf_dict_get(ctx, ocp, PDF_NAME(OCGs));
#            int i, n = PySequence_Size(ON);
#            for (i = 0; i < n; i++) {
#                int xref = 0;
#                if (JM_INT_ITEM(ON, (Py_ssize_t) i, &xref) == 1) continue;
#                pdf_obj *ind = pdf_new_indirect(ctx, pdf, xref, 0);
#                if (pdf_array_contains(ctx, ocgs, ind)) {
#                    pdf_array_push_drop(ctx, onarray, ind);
#                } else {
#                    pdf_drop_obj(ctx, ind);
#                }
#            }
#        }
#        pdf_array_push_drop(ctx, configs, D);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
#
##------------------------------------------------------------------------
## Get OCG arrays from OC configuration
## Returns dict {"basestate":name, "on":list, "off":list, "rbg":list}
##------------------------------------------------------------------------
#static PyObject *
#JM_get_ocg_arrays_imp(fz_context *ctx, pdf_obj *arr)
#{
#    int i, n;
#    PyObject *list = PyList_New(0), *item = NULL;
#    pdf_obj *obj = NULL;
#    if (pdf_is_array(ctx, arr)) {
#        n = pdf_array_len(ctx, arr);
#        for (i = 0; i < n; i++) {
#            obj = pdf_array_get(ctx, arr, i);
#            item = Py_BuildValue("i", pdf_to_num(ctx, obj));
#            if (!PySequence_Contains(list, item)) {
#                LIST_APPEND_DROP(list, item);
#            } else {
#                Py_DECREF(item);
#            }
#        }
#    }
#    return list;
#}
#
#PyObject *
#JM_get_ocg_arrays(fz_context *ctx, pdf_obj *conf)
#{
#    PyObject *rc = PyDict_New(), *list = NULL, *list1 = NULL;
#    int i, n;
#    pdf_obj *arr = NULL, *obj = NULL;
#    fz_try(ctx) {
#        arr = pdf_dict_get(ctx, conf, PDF_NAME(ON));
#        list = JM_get_ocg_arrays_imp(ctx, arr);
#        if (PySequence_Size(list)) {
#            PyDict_SetItemString(rc, "on", list);
#        }
#        Py_DECREF(list);
#        arr = pdf_dict_get(ctx, conf, PDF_NAME(OFF));
#        list = JM_get_ocg_arrays_imp(ctx, arr);
#        if (PySequence_Size(list)) {
#            PyDict_SetItemString(rc, "off", list);
#        }
#        Py_DECREF(list);
#        list = PyList_New(0);
#        arr = pdf_dict_get(ctx, conf, PDF_NAME(RBGroups));
#        if (pdf_is_array(ctx, arr)) {
#            n = pdf_array_len(ctx, arr);
#            for (i = 0; i < n; i++) {
#                obj = pdf_array_get(ctx, arr, i);
#                list1 = JM_get_ocg_arrays_imp(ctx, obj);
#                LIST_APPEND_DROP(list, list1);
#            }
#        }
#        if (PySequence_Size(list)) {
#            PyDict_SetItemString(rc, "rbgroups", list);
#        }
#        Py_DECREF(list);
#        obj = pdf_dict_get(ctx, conf, PDF_NAME(BaseState));
#
#        if (obj) {
#            PyObject *state = NULL;
#            state = Py_BuildValue("s", pdf_to_name(ctx, obj));
#            PyDict_SetItemString(rc, "basestate", state);
#            Py_DECREF(state);
#        }
#    }
#    fz_always(ctx) {
#    }
#    fz_catch(ctx) {
#        Py_CLEAR(rc);
#        PyErr_Clear();
#        fz_rethrow(ctx);
#    }
#    return rc;
#}
#
#
##------------------------------------------------------------------------
## Set OCG arrays from dict of Python lists
## Works with dict like {"basestate":name, "on":list, "off":list, "rbg":list}
##------------------------------------------------------------------------
#static void
#JM_set_ocg_arrays_imp(fz_context *ctx, pdf_obj *arr, PyObject *list)
#{
#    int i, n = PySequence_Size(list);
#    pdf_obj *obj = NULL;
#    pdf_document *pdf = pdf_get_bound_document(ctx, arr);
#    for (i = 0; i < n; i++) {
#        int xref = 0;
#        if (JM_INT_ITEM(list, i, &xref) == 1) continue;
#        obj = pdf_new_indirect(ctx, pdf, xref, 0);
#        pdf_array_push_drop(ctx, arr, obj);
#    }
#    return;
#}
#
#static void
#JM_set_ocg_arrays(fz_context *ctx, pdf_obj *conf, const char *basestate,
#                  PyObject *on, PyObject *off, PyObject *rbgroups)
#{
#    int i, n;
#    pdf_obj *arr = NULL, *obj = NULL, *indobj = NULL;
#    fz_try(ctx) {
#        if (basestate) {
#            pdf_dict_put_name(ctx, conf, PDF_NAME(BaseState), basestate);
#        }
#
#        if (on != Py_None) {
#            pdf_dict_del(ctx, conf, PDF_NAME(ON));
#            if (PySequence_Size(on)) {
#                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(ON), 1);
#                JM_set_ocg_arrays_imp(ctx, arr, on);
#            }
#        }
#
#        if (off != Py_None) {
#            pdf_dict_del(ctx, conf, PDF_NAME(OFF));
#            if (PySequence_Size(off)) {
#                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(OFF), 1);
#                JM_set_ocg_arrays_imp(ctx, arr, off);
#            }
#        }
#
#        if (rbgroups != Py_None) {
#            pdf_dict_del(ctx, conf, PDF_NAME(RBGroups));
#            if (PySequence_Size(rbgroups)) {
#                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(RBGroups), 1);
#                n = PySequence_Size(rbgroups);
#                for (i = 0; i < n; i++) {
#                    PyObject *item0 = PySequence_ITEM(rbgroups, i);
#                    obj = pdf_array_push_array(ctx, arr, 1);
#                    JM_set_ocg_arrays_imp(ctx, obj, item0);
#                    Py_DECREF(item0);
#                }
#            }
#        }
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return;
#}
#
#
##------------------------------------------------------------------------
## Return the items of Resources/Properties (used for Marked Content)
## Argument may be e.g. a page object or a Form XObject
##------------------------------------------------------------------------
#PyObject *
#JM_get_resource_properties(fz_context *ctx, pdf_obj *ref)
#{
#    PyObject *rc = NULL;
#    fz_try(ctx) {
#        pdf_obj *properties = pdf_dict_getl(ctx, ref,
#                         PDF_NAME(Resources),
#                         PDF_NAME(Properties), NULL);
#        if (!properties) {
#            rc = PyTuple_New(0);
#        } else {
#            int i, n = pdf_dict_len(ctx, properties);
#            if (n < 1) {
#                rc = PyTuple_New(0);
#                goto finished;
#            }
#            rc = PyTuple_New(n);
#            for (i = 0; i < n; i++) {
#                pdf_obj *key = pdf_dict_get_key(ctx, properties, i);
#                pdf_obj *val = pdf_dict_get_val(ctx, properties, i);
#                const char *c = pdf_to_name(ctx, key);
#                int xref = pdf_to_num(ctx, val);
#                PyTuple_SET_ITEM(rc, i, Py_BuildValue("si", c, xref));
#            }
#        }
#        finished:;
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return rc;
#}
#
#
##------------------------------------------------------------------------
## Insert an item into Resources/Properties (used for Marked Content)
## Arguments:
## (1) e.g. page object, Form XObject
## (2) marked content name
## (3) xref of the referenced object (insert as indirect reference)
##------------------------------------------------------------------------
#void
#JM_set_resource_property(fz_context *ctx, pdf_obj *ref, const char *name, int xref)
#{
#    pdf_obj *ind = NULL;
#    pdf_obj *properties = NULL;
#    pdf_document *pdf = pdf_get_bound_document(ctx, ref);
#    fz_try(ctx) {
#        ind = pdf_new_indirect(ctx, pdf, xref, 0);
#        if (!ind) THROWMSG(ctx, "bad xref");
#        pdf_obj *resources = pdf_dict_get(ctx, ref, PDF_NAME(Resources));
#        if (!resources) {
#            resources = pdf_dict_put_dict(ctx, ref, PDF_NAME(Resources), 1);
#        }
#        properties = pdf_dict_get(ctx, resources, PDF_NAME(Properties));
#        if (!properties) {
#            properties = pdf_dict_put_dict(ctx, resources, PDF_NAME(Properties), 1);
#        }
#        pdf_dict_put(ctx, properties, pdf_new_name(ctx, name), ind);
#    }
#    fz_always(ctx) {
#        pdf_drop_obj(ctx, ind);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return;
#}
#
#
##------------------------------------------------------------------------
## Add OC object reference to a dictionary
##------------------------------------------------------------------------
#void
#JM_add_oc_object(fz_context *ctx, pdf_document *pdf, pdf_obj *ref, int xref)
#{
#    pdf_obj *indobj = NULL;
#    fz_try(ctx) {
#        indobj = pdf_new_indirect(ctx, pdf, xref, 0);
#        if (!pdf_is_dict(ctx, indobj)) THROWMSG(ctx, "bad 'oc' reference");
#        pdf_obj *type = pdf_dict_get(ctx, indobj, PDF_NAME(Type));
#        if (pdf_objcmp(ctx, type, PDF_NAME(OCG)) == 0 ||
#            pdf_objcmp(ctx, type, PDF_NAME(OCMD)) == 0) {
#            pdf_dict_put(ctx, ref, PDF_NAME(OC), indobj);
#        } else {
#            THROWMSG(ctx, "bad 'oc' type");
#        }
#    }
#    fz_always(ctx) {
#        pdf_drop_obj(ctx, indobj);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
#
##-------------------------------------------------------------------------
## Store info of a font in Python list
##-------------------------------------------------------------------------
#int JM_gather_fonts(fz_context *ctx, pdf_document *pdf, pdf_obj *dict,
#                    PyObject *fontlist, int stream_xref)
#{
#    int i, n, rc = 1;
#    n = pdf_dict_len(ctx, dict);
#    for (i = 0; i < n; i++) {
#        pdf_obj *fontdict = NULL;
#        pdf_obj *subtype = NULL;
#        pdf_obj *basefont = NULL;
#        pdf_obj *name = NULL;
#        pdf_obj *refname = NULL;
#        pdf_obj *encoding = NULL;
#
#        refname = pdf_dict_get_key(ctx, dict, i);
#        fontdict = pdf_dict_get_val(ctx, dict, i);
#        if (!pdf_is_dict(ctx, fontdict)) {
#            fz_warn(ctx, "'%s' is no font dict (%d 0 R)",
#                    pdf_to_name(ctx, refname), pdf_to_num(ctx, fontdict));
#            continue;
#        }
#
#        subtype = pdf_dict_get(ctx, fontdict, PDF_NAME(Subtype));
#        basefont = pdf_dict_get(ctx, fontdict, PDF_NAME(BaseFont));
#        if (!basefont or pdf_is_null(ctx, basefont))
#            name = pdf_dict_get(ctx, fontdict, PDF_NAME(Name));
#        else
#            name = basefont;
#        encoding = pdf_dict_get(ctx, fontdict, PDF_NAME(Encoding));
#        if (pdf_is_dict(ctx, encoding))
#            encoding = pdf_dict_get(ctx, encoding, PDF_NAME(BaseEncoding));
#        int xref = pdf_to_num(ctx, fontdict);
#        char *ext = "n/a";
#        if (xref) ext = JM_get_fontextension(ctx, pdf, xref);
#        PyObject *entry = PyTuple_New(7);
#        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
#        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", ext));
#        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("s", pdf_to_name(ctx, subtype)));
#        PyTuple_SET_ITEM(entry, 3, JM_EscapeStrFromStr(pdf_to_name(ctx, name)));
#        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("s", pdf_to_name(ctx, refname)));
#        PyTuple_SET_ITEM(entry, 5, Py_BuildValue("s", pdf_to_name(ctx, encoding)));
#        PyTuple_SET_ITEM(entry, 6, Py_BuildValue("i", stream_xref));
#        LIST_APPEND_DROP(fontlist, entry);
#    }
#    return rc;
#}
#
##-------------------------------------------------------------------------
## Store info of an image in Python list
##-------------------------------------------------------------------------
#int JM_gather_images(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
#                     PyObject *imagelist, int stream_xref)
#{
#    int i, n, rc = 1;
#    n = pdf_dict_len(ctx, dict);
#    for (i = 0; i < n; i++) {
#        pdf_obj *imagedict, *smask;
#        pdf_obj *refname = NULL;
#        pdf_obj *type;
#        pdf_obj *width;
#        pdf_obj *height;
#        pdf_obj *bpc = NULL;
#        pdf_obj *filter = NULL;
#        pdf_obj *cs = NULL;
#        pdf_obj *altcs;
#
#        refname = pdf_dict_get_key(ctx, dict, i);
#        imagedict = pdf_dict_get_val(ctx, dict, i);
#        if (!pdf_is_dict(ctx, imagedict)) {
#            fz_warn(ctx, "'%s' is no image dict (%d 0 R)",
#                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
#            continue;
#        }
#
#        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
#        if (!pdf_name_eq(ctx, type, PDF_NAME(Image)))
#            continue;
#
#        int xref = pdf_to_num(ctx, imagedict);
#        int gen = 0;
#        smask = pdf_dict_get(ctx, imagedict, PDF_NAME(SMask));
#        if (smask)
#            gen = pdf_to_num(ctx, smask);
#        smask = pdf_dict_get(ctx, imagedict, PDF_NAME(Mask));
#        if (smask)
#            gen = pdf_to_num(ctx, smask);
#        filter = pdf_dict_get(ctx, imagedict, PDF_NAME(Filter));
#        if (pdf_is_array(ctx, filter)) {
#            filter = pdf_array_get(ctx, filter, 0);
#        }
#
#        altcs = NULL;
#        cs = pdf_dict_get(ctx, imagedict, PDF_NAME(ColorSpace));
#        if (pdf_is_array(ctx, cs)) {
#            pdf_obj *cses = cs;
#            cs = pdf_array_get(ctx, cses, 0);
#            if (pdf_name_eq(ctx, cs, PDF_NAME(DeviceN)) ||
#                pdf_name_eq(ctx, cs, PDF_NAME(Separation))) {
#                altcs = pdf_array_get(ctx, cses, 2);
#                if (pdf_is_array(ctx, altcs))
#                    altcs = pdf_array_get(ctx, altcs, 0);
#            }
#        }
#
#        width = pdf_dict_get(ctx, imagedict, PDF_NAME(Width));
#        height = pdf_dict_get(ctx, imagedict, PDF_NAME(Height));
#        bpc = pdf_dict_get(ctx, imagedict, PDF_NAME(BitsPerComponent));
#
#        PyObject *entry = PyTuple_New(10);
#        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
#        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("i", gen));
#        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", pdf_to_int(ctx, width)));
#        PyTuple_SET_ITEM(entry, 3, Py_BuildValue("i", pdf_to_int(ctx, height)));
#        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("i", pdf_to_int(ctx, bpc)));
#        PyTuple_SET_ITEM(entry, 5, JM_EscapeStrFromStr(pdf_to_name(ctx, cs)));
#        PyTuple_SET_ITEM(entry, 6, JM_EscapeStrFromStr(pdf_to_name(ctx, altcs)));
#        PyTuple_SET_ITEM(entry, 7, JM_EscapeStrFromStr(pdf_to_name(ctx, refname)));
#        PyTuple_SET_ITEM(entry, 8, JM_EscapeStrFromStr(pdf_to_name(ctx, filter)));
#        PyTuple_SET_ITEM(entry, 9, Py_BuildValue("i", stream_xref));
#        LIST_APPEND_DROP(imagelist, entry);
#    }
#    return rc;
#}
#
##-------------------------------------------------------------------------
## Store info of a /Form xobject in Python list
##-------------------------------------------------------------------------
#int JM_gather_forms(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
#                     PyObject *imagelist, int stream_xref)
#{
#    int i, rc = 1, n = pdf_dict_len(ctx, dict);
#    fz_rect bbox;
#    pdf_obj *o = NULL, *m = NULL;
#    for (i = 0; i < n; i++) {
#        pdf_obj *imagedict;
#        pdf_obj *refname = NULL;
#        pdf_obj *type;
#
#        refname = pdf_dict_get_key(ctx, dict, i);
#        imagedict = pdf_dict_get_val(ctx, dict, i);
#        if (!pdf_is_dict(ctx, imagedict)) {
#            fz_warn(ctx, "'%s' is no form dict (%d 0 R)",
#                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
#            continue;
#        }
#
#        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
#        if (!pdf_name_eq(ctx, type, PDF_NAME(Form)))
#            continue;
#
#        o = pdf_dict_get(ctx, imagedict, PDF_NAME(BBox));
#        m = pdf_dict_get(ctx, imagedict, PDF_NAME(Matrix));
#        if (o) {
#            if (m) {
#                bbox = fz_transform_rect(pdf_to_rect(ctx, o), pdf_to_matrix(ctx, m));
#            } else {
#                bbox = pdf_to_rect(ctx, o);
#            }
#        } else {
#            bbox = fz_infinite_rect;
#        }
#        int xref = pdf_to_num(ctx, imagedict);
#
#        PyObject *entry = PyTuple_New(4);
#        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
#        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", pdf_to_name(ctx, refname)));
#        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", stream_xref));
#        PyTuple_SET_ITEM(entry, 3, JM_py_from_rect(bbox));
#        LIST_APPEND_DROP(imagelist, entry);
#    }
#    return rc;
#}
#
##-------------------------------------------------------------------------
## Step through /Resources, looking up image, xobject or font information
##-------------------------------------------------------------------------
#void JM_scan_resources(fz_context *ctx, pdf_document *pdf, pdf_obj *rsrc,
#                 PyObject *liste, int what, int stream_xref,
#                 PyObject *tracer)
#{
#    pdf_obj *font, *xobj, *subrsrc;
#    int i, n, sxref;
#    if (pdf_mark_obj(ctx, rsrc)) {
#        fz_warn(ctx, "Circular dependencies! Consider page cleaning.");
#        return;  // Circular dependencies!
#    }
#
#    fz_try(ctx) {
#
#        xobj = pdf_dict_get(ctx, rsrc, PDF_NAME(XObject));
#
#        if (what == 1) {  // lookup fonts
#            font = pdf_dict_get(ctx, rsrc, PDF_NAME(Font));
#            JM_gather_fonts(ctx, pdf, font, liste, stream_xref);
#        } else if (what == 2) {  // look up images
#            JM_gather_images(ctx, pdf, xobj, liste, stream_xref);
#        } else if (what == 3) {  // look up form xobjects
#            JM_gather_forms(ctx, pdf, xobj, liste, stream_xref);
#        } else {  // should never happen
#            goto finished;
#        }
#
#        // check if we need to recurse into Form XObjects
#        n = pdf_dict_len(ctx, xobj);
#        for (i = 0; i < n; i++) {
#            pdf_obj *obj = pdf_dict_get_val(ctx, xobj, i);
#            if (pdf_is_stream(ctx, obj)) {
#                sxref = pdf_to_num(ctx, obj);
#            } else {
#                sxref = 0;
#            }
#            subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
#            if (subrsrc) {
#                PyObject *sxref_t = Py_BuildValue("i", sxref);
#                if (PySequence_Contains(tracer, sxref_t) == 0) {
#                    LIST_APPEND_DROP(tracer, sxref_t);
#                    JM_scan_resources(ctx, pdf, subrsrc, liste, what, sxref, tracer);
#                } else {
#                    Py_DECREF(sxref_t);
#                    PyErr_Clear();
#                    fz_warn(ctx, "Circular dependencies! Consider page cleaning.");
#                    goto finished;
#                }
#            }
#        }
#        finished:;
#    }
#    fz_always(ctx) {
#        pdf_unmark_obj(ctx, rsrc);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#}
#
#
##-----------------------------------------------------------------------------
## Convert any MuPDF document to a PDF
## Returns bytes object containing the PDF, created via 'write' function.
##-----------------------------------------------------------------------------
#PyObject *JM_convert_to_pdf(fz_context *ctx, fz_document *doc, int fp, int tp, int rotate)
#{
#    pdf_document *pdfout = pdf_create_document(ctx);  // new PDF document
#    int i, incr = 1, s = fp, e = tp;
#    if (fp > tp) {
#        incr = -1;           // count backwards
#        s = tp;              // adjust ...
#        e = fp;              // ... range
#    }
#    fz_rect mediabox;
#    int rot = JM_norm_rotation(rotate);
#    fz_device *dev = NULL;
#    fz_buffer *contents = NULL;
#    pdf_obj *resources = NULL;
#    fz_page *page;
#    fz_var(dev);
#    fz_var(contents);
#    fz_var(resources);
#    fz_var(page);
#    for (i = fp; INRANGE(i, s, e); i += incr) {  // interpret & write document pages as PDF pages
#        fz_try(ctx) {
#            page = fz_load_page(ctx, doc, i);
#            mediabox = fz_bound_page(ctx, page);
#            dev = pdf_page_write(ctx, pdfout, mediabox, &resources, &contents);
#            fz_run_page(ctx, page, dev, fz_identity, NULL);
#            fz_close_device(ctx, dev);
#            fz_drop_device(ctx, dev);
#            dev = NULL;
#            pdf_obj *page_obj = pdf_add_page(ctx, pdfout, mediabox, rot, resources, contents);
#            pdf_insert_page(ctx, pdfout, -1, page_obj);
#            pdf_drop_obj(ctx, page_obj);
#        }
#        fz_always(ctx) {
#            pdf_drop_obj(ctx, resources);
#            fz_drop_buffer(ctx, contents);
#            fz_drop_device(ctx, dev);
#            fz_drop_page(ctx, page);
#        }
#        fz_catch(ctx) {
#            fz_rethrow(ctx);
#        }
#    }
#    // PDF created - now write it to Python bytearray
#    PyObject *r = NULL;
#    fz_output *out = NULL;
#    fz_buffer *res = NULL;
#    // prepare write options structure
#    pdf_write_options opts = { 0 };
#    opts.do_garbage         = 4;
#    opts.do_compress        = 1;
#    opts.do_compress_images = 1;
#    opts.do_compress_fonts  = 1;
#    opts.do_sanitize        = 1;
#    opts.do_incremental     = 0;
#    opts.do_ascii           = 0;
#    opts.do_decompress      = 0;
#    opts.do_linear          = 0;
#    opts.do_clean           = 1;
#    opts.do_pretty          = 0;
#
#    fz_try(ctx) {
#        res = fz_new_buffer(ctx, 8192);
#        out = fz_new_output_with_buffer(ctx, res);
#        pdf_write_document(ctx, pdfout, out, &opts);
#        unsigned char *c = NULL;
#        size_t len = fz_buffer_storage(gctx, res, &c);
#        r = PyBytes_FromStringAndSize((const char *) c, (Py_ssize_t) len);
#    }
#    fz_always(ctx) {
#        pdf_drop_document(ctx, pdfout);
#        fz_drop_output(ctx, out);
#        fz_drop_buffer(ctx, res);
#    }
#    fz_catch(ctx) {
#        fz_rethrow(ctx);
#    }
#    return r;
#}
#
#
#typedef struct
#{
#	fz_device super;
#	PyObject *out;
#} jm_tracedraw_device;
#
#static void
#jm_tracedraw_matrix(fz_context *ctx, PyObject *out, fz_matrix ctm)
#{
#	PyObject *list = PyList_New(0);
#    LIST_APPEND_DROP(list, PyUnicode_FromString("matrix"));
#    LIST_APPEND_DROP(list, JM_py_from_matrix(ctm));
#    LIST_APPEND_DROP(out, list);
#}
#
#static void
#jm_tracedraw_color(fz_context *ctx, PyObject *out, fz_colorspace *colorspace, const float *color, float #alpha)
#{
#	int i, n;
#	if (colorspace)
#	{
#		n = fz_colorspace_n(ctx, colorspace);
#		LIST_APPEND_DROP(out, Py_BuildValue("ss", "colorspace", fz_colorspace_name(ctx, colorspace)));
#		PyObject *xlist=PyList_New(0);
#		LIST_APPEND_DROP(xlist, Py_BuildValue("s", "color"));
#		for (i = 0; i < n; i++)
#			LIST_APPEND_DROP(xlist, Py_BuildValue("f", color[i]));
#		LIST_APPEND_DROP(out, xlist);
#	}
#	if (alpha < 1)
#		LIST_APPEND_DROP(out, Py_BuildValue("sf", "alpha", alpha));
#}
#
#static void
#trace_moveto(fz_context *ctx, void *dev_, float x, float y)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#    PyObject *list = PyList_New(0);
#    LIST_APPEND_DROP(list, PyUnicode_FromString("m"));
#    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x, y)));
#    LIST_APPEND_DROP(out, list);
#}
#
#static void
#trace_lineto(fz_context *ctx, void *dev_, float x, float y)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#    PyObject *list = PyList_New(0);
#    LIST_APPEND_DROP(list, PyUnicode_FromString("l"));
#    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x, y)));
#    LIST_APPEND_DROP(out, list);
#}
#
#static void
#trace_curveto(fz_context *ctx, void *dev_, float x1, float y1, float x2, float y2, float x3, float y3)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#    PyObject *list = PyList_New(0);
#    LIST_APPEND_DROP(list, PyUnicode_FromString("c"));
#    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x1, y1)));
#    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x2, y2)));
#    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x3, y3)));
#    LIST_APPEND_DROP(out, list);
#}
#
#static void
#trace_close(fz_context *ctx, void *dev_)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#    LIST_APPEND_DROP(out, Py_BuildValue("s", "closePath"));
#}
#
#static const fz_path_walker trace_path_walker =
#	{
#		trace_moveto,
#		trace_lineto,
#		trace_curveto,
#		trace_close};
#
#static void
#jm_tracedraw_path(fz_context *ctx, jm_tracedraw_device *dev, const fz_path *path)
#{
#	fz_walk_path(ctx, path, &trace_path_walker, dev);
#}
#
#static void
#jm_tracedraw_fill_path(fz_context *ctx, fz_device *dev_, const fz_path *path,
#						int even_odd, fz_matrix ctm, fz_colorspace *colorspace,
#						const float *color, float alpha, fz_color_params color_params)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *) dev_;
#	PyObject *out = dev->out;
#	PyObject *list = PyList_New(0);
#	LIST_APPEND_DROP(list, PyUnicode_FromString("fill"));
#	if (even_odd)
#		LIST_APPEND_DROP(list, PyUnicode_FromString("even-odd"));
#	else
#		LIST_APPEND_DROP(list, PyUnicode_FromString("non-zero"));
#	jm_tracedraw_matrix(ctx, list, ctm);
#	jm_tracedraw_color(ctx, list, colorspace, color, alpha);
#	LIST_APPEND_DROP(out, list);
#	jm_tracedraw_path(ctx, dev, path);
#	LIST_APPEND_DROP(out, PyUnicode_FromString("efill"));
#}
#
#static void
#jm_tracedraw_stroke_path(fz_context *ctx, fz_device *dev_, const fz_path *path,
#						 const fz_stroke_state *stroke, fz_matrix ctm,
#						 fz_colorspace *colorspace, const float *color, float alpha,
#						 fz_color_params color_params)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#	int i;
#    PyObject *list = PyList_New(0);
#    LIST_APPEND_DROP(list, PyUnicode_FromString("stroke"));
#	jm_tracedraw_matrix(ctx, list, ctm);
#	LIST_APPEND_DROP(list, Py_BuildValue("sf", "w", stroke->linewidth));
#	LIST_APPEND_DROP(list, Py_BuildValue("sf", "miter", stroke->miterlimit));
#	LIST_APPEND_DROP(list, Py_BuildValue("siii", "lineCap",
#					 stroke->start_cap, stroke->dash_cap, stroke->end_cap));
#	LIST_APPEND_DROP(list, Py_BuildValue("si", "lineJoin", stroke->linejoin));
#
#	if (stroke->dash_len)
#	{
#		LIST_APPEND_DROP(list, Py_BuildValue("sf", "dashPhase", stroke->dash_phase));
#		PyObject *xlist=PyList_New(0);
#		LIST_APPEND_DROP(xlist, Py_BuildValue("s", "dashes"));
#		for (i = 0; i < stroke->dash_len; i++)
#			LIST_APPEND_DROP(xlist, Py_BuildValue("f", stroke->dash_list[i]));
#		LIST_APPEND_DROP(list, xlist);
#	}
#	jm_tracedraw_color(ctx, list, colorspace, color, alpha);
#	LIST_APPEND_DROP(out, list);
#	jm_tracedraw_path(ctx, dev, path);
#	LIST_APPEND_DROP(out, Py_BuildValue("s", "estroke"));
#}
#
#static void
#jm_tracedraw_clip_path(fz_context *ctx, fz_device *dev_, const fz_path *path, int even_odd, fz_matrix #ctm, fz_rect scissor)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#	PyObject *list = PyList_New(0);
#	LIST_APPEND_DROP(list, Py_BuildValue("s", "clip"));
#
#	if (even_odd)
#		LIST_APPEND_DROP(list, Py_BuildValue("s", "even-odd"));
#	else
#		LIST_APPEND_DROP(list, Py_BuildValue("s", "non-zero"));
#	jm_tracedraw_matrix(ctx, list, ctm);
#	LIST_APPEND_DROP(out, list);
#	jm_tracedraw_path(ctx, dev, path);
#	LIST_APPEND_DROP(out, Py_BuildValue("s", "eclip"));
#}
#
#static void
#jm_tracedraw_clip_stroke_path(fz_context *ctx, fz_device *dev_, const fz_path *path, const #fz_stroke_state *stroke, fz_matrix ctm, fz_rect scissor)
#{
#	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
#	PyObject *out = dev->out;
#	PyObject *list = PyList_New(0);
#	LIST_APPEND_DROP(list, Py_BuildValue("s", "clip-stroke"));
#	jm_tracedraw_matrix(ctx, list, ctm);
#	LIST_APPEND_DROP(out, list);
#	jm_tracedraw_path(ctx, dev, path);
#	LIST_APPEND_DROP(out, Py_BuildValue("s", "eclip-stroke"));
#}
#
#fz_device *JM_new_tracedraw_device(fz_context *ctx, PyObject *out)
#{
#	jm_tracedraw_device *dev = fz_new_derived_device(ctx, jm_tracedraw_device);
#
#	dev->super.fill_path = jm_tracedraw_fill_path;
#	dev->super.stroke_path = jm_tracedraw_stroke_path;
#	dev->super.clip_path = NULL; //jm_tracedraw_clip_path;
#	dev->super.clip_stroke_path = jm_tracedraw_clip_stroke_path;
#
#	dev->super.fill_text = NULL;
#	dev->super.stroke_text = NULL;
#	dev->super.clip_text = NULL;
#	dev->super.clip_stroke_text = NULL;
#	dev->super.ignore_text = NULL;
#
#	dev->super.fill_shade = NULL;
#	dev->super.fill_image = NULL;
#	dev->super.fill_image_mask = NULL;
#	dev->super.clip_image_mask = NULL;
#
#	dev->super.pop_clip = NULL;
#
#	dev->super.begin_mask = NULL;
#	dev->super.end_mask = NULL;
#	dev->super.begin_group = NULL;
#	dev->super.end_group = NULL;
#
#	dev->super.begin_tile = NULL;
#	dev->super.end_tile = NULL;
#
#	dev->super.begin_layer = NULL;
#	dev->super.end_layer = NULL;
#
#	dev->super.render_flags = NULL;
#	dev->super.set_default_colorspaces = NULL;
#
#	dev->out = out;
#
#	return (fz_device *)dev;
#}
