#! /usr/bin/env python3

'''
Creates an object file containg a single piece of binary data with
the following symbols:

    <name>: A `const char[]` containing data in <path_in>.
    <name>_size: A `const long` containing size of data.

We create a temporary .c file and compile it with `cc`.

Args:

    -c <extra>
        Basic C compiler command; default is `cc -c`. For example `cc -c -fPIC`.
    -i <path_in>:
        Required, the input file, typically containing binary data.
    -o <path_out>:
        Required, the output file, typically with suffix `.o`.
    -p 0|1
        If 1 we do not delete the temporary .c file.
    -n <name>:
        Name of symbol. If this is not specified, we use the leafname of
        <path_in>, with characters other than a-zA-Z0-9_ replaced by `_`, all
        prefixed with `_binary`.
    -v 0|1:
        If 1 we output extra diagnostics.
'''

import os
import re
import subprocess
import sys
import tempfile
import time


def log(text):
    print(f'{sys.argv[0]}: {text}')

def main():

    path_in = None
    path_out = None
    name = None
    verbose = 0
    cc = 'cc -c'
    preserve = False
    path_c = None

    args = iter(sys.argv[1:])
    while 1:
        try:
            arg = next(args)
        except StopIteration:
            break
        if arg in ('-h', '--help'):
            print(__doc__)
            return 1
        elif arg == '-c':
            cc = next(args)
        elif arg == '-i':
            path_in = next(args)
        elif arg == '-m':
            path_c = next(args)
        elif arg == '-n':
            name = next(args)
        elif arg == '-o':
            path_out = next(args)
        elif arg == '-p':
            preserve = int(next(args))
        elif arg == '-v':
            verbose = int(next(args))
        else:
            raise Exception(f'Unrecognised arg: {arg!r}')

    if not path_in:
        raise Exception(f'Expected: -i <path_in>')
    if not path_out:
        raise Exception(f'Expected: -o <path_out>')

    if not name:
        name = os.path.basename(path_in)
        name2 = re.sub('[^a-zA-Z0-9_]', '_', name)
        if verbose and name2 != name:
            log(f'name: {name} => {name2}')
        name = f'_binary_{name2}'
        log(f'Using default name: {name!r}')

    if path_c:
        fd_c = os.open(path_c, os.O_CREAT | os.O_TRUNC | os.O_WRONLY)
    else:
        fd_c, path_c = tempfile.mkstemp('.c')
    try:
        with open(path_in, 'rb') as f_in:
            bytes_in = f_in.read()
        with open(fd_c, 'w') as f_c:
            # Writing `char foo [] = "...";` where the string contains \xHH
            # for each byte, works much better than `char foo[] = { N0, N1,
            # ...};` where each N is an integer - the latter can result in
            # `cc` running out of memory.
            #
            f_c.write(f'/* Generated by:\n')
            f_c.write(f'    {" ".join(sys.argv)}\n')
            f_c.write(f'*/\n')
            f_c.write(f'\n')
            f_c.write(f'const unsigned char {name}[] = "')
            t0 = time.time()
            for i, b in enumerate(bytes_in):
                if i % 16 == 0:
                    # Start a new line.
                    f_c.write('"\n"')
                    if verbose:
                        t = time.time()
                        if t - t0 > 5:
                            log(f'Writing {path_c}: {i*100//len(bytes_in)}% ({i} / {len(bytes_in)})')
                            t0 = time.time()
                f_c.write(f'\\x{b:02x}')
            f_c.write('"\n;\n')
            # We use `- 1` to exclude the terminating 0 that C always appends.
            #
            f_c.write(f'const unsigned int {name}_size = sizeof({name}) - 1;\n')
        path_out_dir = os.path.dirname(path_out)
        if path_out_dir:
            os.makedirs(path_out_dir, exist_ok=True)
        command = f'{cc} {path_c} -o {path_out}'
        if verbose:
            log(f'Running: {command}')
        subprocess.run(command, shell=1, check=1)
    finally:
        if preserve:
            log(f'Preserving intermediate file: {path_c!r}')
        else:
            os.remove(path_c)
    if verbose:
        log(f'Have created: {path_out!r}')

if __name__ == '__main__':
    e = main()
    sys.exit(e)
